Disassembly Listing for Base
Generated From:
D:/Progetti/Termometro wireless/Firmware/Base.X/dist/default/debug/Base.X.debug.elf
7-nov-2014 13.45.31

---  D:/Progetti/Termometro wireless/Firmware/Base.X/SYS.c  ---------------------------------------------
1:             
2:             #include <xc.h>
3:             #include "IN.h"
4:             #include "DIN.h"
5:             #include "CC1.h"
6:             #include "RTX.h"
7:             #include "PGM.h"
8:             #include "SYS.h"
9:             
10:            //Definizione macro.
11:            #define mTMR0Reset() TMR0=255-156
12:            #define mSysInit() OPTION_REG=0b00000110; OSCCON=0b01110001; WDTCON=0b00001001; mTMR0Reset(); INTCON|=0b00100000; INTCON&=0b11111011; PIR1=0b00000000; PIR2=0b00000000; PIE1=0b00000000; PIE2=0b00000000	//prescaler timer0 1:128, frequenza 8MHz
13:            
14:            void SYSInit(unsigned char state)
15:            {
0889  00F2     MOVWF val
16:                switch(state)
088A  28A3     GOTO 0xA3
08A3  0872     MOVF val, W
17:                {
18:                    case 0:
19:                        //Inizializzazione hardware.
20:                        mSysInit();
088B  3006     MOVLW 0x6
21:                        break;
089F  0008     RETURN
22:                    case 1:
23:                        //Inizializzazione variabili.
24:                        u_SYS_STA.VAL=0;
08A0  0021     MOVLB 0x1
25:                        break;
26:            //        case 2:
27:            //            //Inizializzazione applicazione.
28:            //            break;
29:                }
08A2  0008     RETURN
30:            }
08AB  0008     RETURN
31:            
32:            void SYSInt(void)
33:            {
34:            	//Setta il flag per il tick di sistema.
35:            	u_SYS_STA.TICK=1;
1584  0021     MOVLB 0x1
1585  142C     BSF u_SYS_STA, 0x0
36:            
37:            	//Ricarica il timer 0.
38:            	mTMR0Reset();
1586  3063     MOVLW 0x63
1587  0020     MOVLB 0x0
1588  0095     MOVWF TMR0
39:            }	
1589  0008     RETURN
40:            
41:            void SYSTask(void)
42:            {
43:                //Gestisce il tick di sistema.
44:                if(u_SYS_STA.TICK)
0AC0  0021     MOVLB 0x1
0AC1  1C2C     BTFSS u_SYS_STA, 0x0
0AC2  2ACD     GOTO 0x2CD
45:                {
46:                    //Cancella il flag.
47:                    u_SYS_STA.TICK=0;
0AC3  102C     BCF u_SYS_STA, 0x0
48:            
49:                    //Chiama le funzioni interessate.
50:                    RTXTick();
0AC4  3189     MOVLP 0x9
0AC5  21B6     CALL 0x1B6
0AC6  318A     MOVLP 0xA
51:                    DINTick();
0AC7  3188     MOVLP 0x8
0AC8  20AC     CALL 0xAC
0AC9  318A     MOVLP 0xA
52:                    PGMTick();
0ACA  3196     MOVLP 0x16
0ACB  2617     CALL 0x617
0ACC  318A     MOVLP 0xA
53:                }
54:            
55:                if(u_in_ev_down.sel)
0ACD  0021     MOVLB 0x1
0ACE  1C2E     BTFSS u_in_ev_down, 0x0
0ACF  2AD4     GOTO 0x2D4
56:                {
57:                    //Cancella il flag.
58:                    u_in_ev_down.sel=0;
0AD0  102E     BCF u_in_ev_down, 0x0
59:                    PGMSelDown();
0AD1  3195     MOVLP 0x15
0AD2  25C8     CALL 0x5C8
0AD3  318A     MOVLP 0xA
60:                }
61:                if(u_in_ev_long.sel)
0AD4  0021     MOVLB 0x1
0AD5  1C2F     BTFSS u_in_ev_long, 0x0
0AD6  2ADB     GOTO 0x2DB
62:                {
63:                    //Cancella il flag.
64:                    u_in_ev_long.sel=0;
0AD7  102F     BCF u_in_ev_long, 0x0
65:                    PGMSelLong();
0AD8  3195     MOVLP 0x15
0AD9  25DF     CALL 0x5DF
0ADA  318A     MOVLP 0xA
66:                }
67:            
68:            
69:                //Controlla se la programmazione è andata a buon fine.
70:                if(rtx_flg.pgmDone)
0ADB  0021     MOVLB 0x1
0ADC  1CA7     BTFSS rtx_flg, 0x1
0ADD  2AE2     GOTO 0x2E2
71:                {
72:                    //Cancella il flag.
73:                    rtx_flg.pgmDone=0;
0ADE  10A7     BCF rtx_flg, 0x1
74:                    //Chiama la funzione per terminare la programmazione.
75:                    PGMPgmOff();
0ADF  3195     MOVLP 0x15
0AE0  258A     CALL 0x58A
0AE1  318A     MOVLP 0xA
76:                }
77:            
78:                //Flag evento di segnalazione della programmazione.
79:                if(pgm_flg.evPgmOn)
0AE2  0021     MOVLB 0x1
0AE3  1CA6     BTFSS pgm_flg, 0x1
0AE4  2AE9     GOTO 0x2E9
80:                {
81:                    //Cancella il flag.
82:                    pgm_flg.evPgmOn=0;
0AE5  10A6     BCF pgm_flg, 0x1
83:                    //Chiama la funzione.
84:                    RTXPgmOn();
0AE6  3195     MOVLP 0x15
0AE7  25B4     CALL 0x5B4
0AE8  318A     MOVLP 0xA
85:                }
86:                if(pgm_flg.evPgmOff)
0AE9  0021     MOVLB 0x1
0AEA  1D26     BTFSS pgm_flg, 0x2
0AEB  0008     RETURN
87:                {
88:                    //Cancella il flag.
89:                    pgm_flg.evPgmOff=0;
0AEC  1126     BCF pgm_flg, 0x2
90:                    //Chiama la funzione.
91:                    RTXPgmOff();
0AED  3195     MOVLP 0x15
0AEE  259C     CALL 0x59C
0AEF  0008     RETURN
92:                }
93:            }
0AF0  0020     MOVLB 0x0
---  D:/Progetti/Termometro wireless/Firmware/Base.X/SPI.c  ---------------------------------------------
1:             
2:             #include <xc.h>
3:             #include "SPI.h"
4:             
5:             //Definizioni macro.
6:             #define mSpiInit() TRISC|=0b00010000; TRISC&=0b11010111; SSPCONbits.SSPEN=0; SSPBUF=0x00; SSPCON1=0b00000001; SSPCON2=0b00000000; SSPSTAT=0b01000000; SSPCONbits.SSPEN=1
7:             
8:             void SPIInit(unsigned char state)
9:             {
17C4  00F2     MOVWF val
10:            	switch(state)
17C5  2FD6     GOTO 0x7D6
17D6  0872     MOVF val, W
17D7  3A00     XORLW 0x0
17D8  1903     BTFSC STATUS, 0x2
17D9  2FC6     GOTO 0x7C6
17DA  3A01     XORLW 0x1
17DB  1903     BTFSC STATUS, 0x2
17DC  2FE1     GOTO 0x7E1
17DD  3A03     XORLW 0x3
17DE  1903     BTFSC STATUS, 0x2
17DF  2FE1     GOTO 0x7E1
17E0  2FE1     GOTO 0x7E1
11:            	{
12:            		case 0:
13:            			//Inizializzazione hardware.
14:            			mSpiInit();
17C6  0021     MOVLB 0x1
17C7  160E     BSF TRISC, 0x4
17C8  30D7     MOVLW 0xD7
17C9  00F1     MOVWF 0xF1
17CA  0871     MOVF 0xF1, W
17CB  058E     ANDWF TRISC, F
17CC  0024     MOVLB 0x4
17CD  1295     BCF SSPCON1, 0x5
17CE  0191     CLRF SSPBUF
17CF  3001     MOVLW 0x1
17D0  0095     MOVWF SSPCON1
17D1  0196     CLRF SSPCON2
17D2  3040     MOVLW 0x40
17D3  0094     MOVWF SSPSTAT
17D4  1695     BSF SSPCON1, 0x5
15:            			break;
16:            		case 1:
17:            			//Inizializzazione variabili.
18:            			break;
19:            		case 2:
20:            			//Inizializzazione applicazione.
21:            			break;
22:            	}
17D5  0008     RETURN
23:            }
17E1  0008     RETURN
24:            
25:            void SPIRead(unsigned char *dstPtr,unsigned char len)
26:            {
27:            	unsigned char i;
28:            	
29:            	for(i=0;i<len;i++)
093F  01F9     CLRF 0x279
0940  0873     MOVF 0x273, W
0941  0279     SUBWF 0x279, W
0942  1803     BTFSC 0x203, 0x0
0943  0008     RETURN
0960  3001     MOVLW 0x1
0961  00F4     MOVWF 0x274
0962  0874     MOVF 0x274, W
0963  07F9     ADDWF 0x279, F
0964  2940     GOTO 0x140
30:            	{
31:            		PIR1bits.SSPIF=0;
0944  0020     MOVLB 0x0
0945  1191     BCF PIR1, 0x3
32:            		SSPBUF=0xFF;
0946  30FF     MOVLW 0xFF
0947  0024     MOVLB 0x4
0948  0091     MOVWF SSPBUF
33:            		while(!(PIR1bits.SSPIF))
0949  0020     MOVLB 0x0
094A  1991     BTFSC PIR1, 0x3
094B  294E     GOTO 0x14E
094D  2949     GOTO 0x149
34:            			NOP();
094C  0000     NOP
35:            		(*(dstPtr+i))=SSPBUF;
094E  0024     MOVLB 0x4
094F  0811     MOVF SSPBUF, W
0950  00F4     MOVWF 0x274
0951  0879     MOVF 0x279, W
0952  00F5     MOVWF 0x275
0953  01F6     CLRF 0x276
0954  0875     MOVF 0x275, W
0955  0771     ADDWF 0x271, W
0956  00F7     MOVWF 0x277
0957  0876     MOVF 0x276, W
0958  3D72     ADDWFC 0x272, W
0959  00F8     MOVWF 0x278
095A  0877     MOVF 0x277, W
095B  0086     MOVWF 0x206
095C  0878     MOVF 0x278, W
095D  0087     MOVWF 0x207
095E  0874     MOVF 0x274, W
095F  0081     MOVWF 0x201
36:            	}
37:            }
0965  300F     MOVLW 0xF
0966  00F1     MOVWF 0x271
0967  3000     MOVLW 0x0
0968  00F2     MOVWF 0x272
0969  3196     MOVLP 0x16
096A  26ED     CALL 0x6ED
096B  3189     MOVLP 0x9
38:            
39:            void SPIWrite(unsigned char *srcPtr,unsigned char len)
40:            {
41:            	unsigned char i;
42:            	
43:            	for(i=0;i<len;i++)
178A  01F6     CLRF 0x276
178B  0873     MOVF 0x273, W
178C  0276     SUBWF 0x276, W
178D  1803     BTFSC 0x203, 0x0
178E  0008     RETURN
17A2  3001     MOVLW 0x1
17A3  00F4     MOVWF 0x274
17A4  0874     MOVF 0x274, W
17A5  07F6     ADDWF 0x276, F
17A6  2F8B     GOTO 0x78B
44:            	{
45:            		PIR1bits.SSPIF=0;
178F  0020     MOVLB 0x0
1790  1191     BCF PIR1, 0x3
46:            		SSPBUF=(*(srcPtr+i));
1791  0876     MOVF bf, W
1792  00F4     MOVWF ff2
1793  01F5     CLRF product
1794  0874     MOVF ff2, W
1795  0771     ADDWF multiplier, W
1796  0086     MOVWF FSR1
1797  0875     MOVF product, W
1798  3D72     ADDWFC val, W
1799  0087     MOVWF FSR1H
179A  0801     MOVF INDF1, W
179B  0024     MOVLB 0x4
179C  0091     MOVWF SSPBUF
47:            		while(!(PIR1bits.SSPIF))
179D  0020     MOVLB 0x0
179E  1991     BTFSC PIR1, 0x3
179F  2FA2     GOTO 0x7A2
17A1  2F9D     GOTO 0x79D
48:            			NOP();
17A0  0000     NOP
49:            	}
50:            }
17A7  01F5     CLRF product
17A8  01F6     CLRF bf
17A9  1C71     BTFSS multiplier, 0x0
17AA  2FAF     GOTO 0x7AF
17AB  0873     MOVF multiplicand, W
17AC  07F5     ADDWF product, F
17AD  0874     MOVF ff2, W
17AE  3DF6     ADDWFC bf, F
17AF  3001     MOVLW 0x1
17B0  35F3     LSLF multiplicand, F
17B1  0DF4     RLF ff2, F
17B2  0B89     DECFSZ WREG, F
17B3  2FB0     GOTO 0x7B0
17B4  3001     MOVLW 0x1
17B5  36F2     LSRF val, F
17B6  0CF1     RRF multiplier, F
17B7  0B89     DECFSZ WREG, F
17B8  2FB5     GOTO 0x7B5
17B9  0872     MOVF val, W
17BA  0471     IORWF multiplier, W
17BB  1D03     BTFSS STATUS, 0x2
17BC  2FA9     GOTO 0x7A9
17BD  0876     MOVF bf, W
17BE  01F2     CLRF val
17BF  07F2     ADDWF val, F
17C0  0875     MOVF product, W
17C1  01F1     CLRF multiplier
17C2  07F1     ADDWF multiplier, F
17C3  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/RTX.c  ---------------------------------------------
1:             #include <xc.h>
2:             #include <stdlib.h>
3:             #include <stdio.h>
4:             #include "Base.h"
5:             #include "CC1.h"
6:             #include "PGM.h"
7:             #include "NVM.h"
8:             #include "OUT.h"
9:             #include "IN.h"
10:            #include "DPY.h"
11:            #include "smartrf_CC1101.h"
12:            #include "RTX.h"
13:            #include "DLY.h"
14:            
15:            //Definizioni.
16:            #define ADDR_CC1_FIFO		0x3F	//Indirizzo del CC1101 per la lettura del FIFO.
17:            #define ADDR_CC1_STA		0x35	//Indirizzo del CC1101 per la lettura del byte di stato.
18:            #define ADDR_CC1_BYTX		0x3A	//Indirizzo del CC1101 per la lettura del byte contenente il nuemro di byte in trasmissione e presenti nel FIFO.
19:            #define ADDR_CC1_BYRX		0x3B	//Indirizzo del CC1101 per la lettura del byte contenente il nuemro di byte ricevuti e presenti nel FIFO.
20:            
21:            #define TICK_TMRRCVPKT	10                         //Base tempi 10ms, 1s di timeout.
22:            #define MAX_SNDDATA     5                           //Numero massimo di invii in caso di non ricezione della risposta.
23:            #define PKT_LEN         SMARTRF_SETTING_PKTLEN      //Numero di byte per pacchetto.
24:            
25:            #define MAX_DECNUM 2    //Numero massimo di decimali.
26:            
27:            #define MAX_TMRCALIBRATION 1000          //Massimo valore per il timer di calibrazione.
28:            
29:            typedef enum _RTX_OP
30:            {
31:                DAT=0x00,
32:                PGM=0x01,
33:            
34:                rDAT=0x80,
35:                rPGM=0x81
36:            }te_RTX_OP;
37:            
38:            typedef enum _RTX_UPD_DPY
39:            {
40:                UPD_DPY_RST,
41:                UPD_DPY_TEMP,
42:                UPD_DPY_PGM,
43:                UPD_DPY_PGMDONE
44:            }te_RTX_UPD_DPY;
45:            
46:            
47:            static char strTitle[DPY_COL_NUM],strTemp[DPY_COL_NUM],sta,numRxByte,numTxByte;
48:            static unsigned char pktRx[PKT_LEN],pktTx[PKT_LEN],tmrRcvPkt;
49:            static unsigned short tmrCalibration;
50:            
51:            static void RTXSndPkt(unsigned char *,unsigned char);
52:            static void RTXRcvPkt(unsigned char *,unsigned char);
53:            static void RTXSetSensSta(unsigned char,unsigned char);
54:            static void RTXSendPgm(void);
55:            static void RTXSendRData(void);
56:            static void RTXUpdateDisplay(te_RTX_UPD_DPY);
57:            static void RTXSup(void);
58:            
59:            void RTXInit(unsigned char state)
60:            {
0919  0020     MOVLB 0x0
61:                switch(state)
091B  2932     GOTO 0x132
0932  0020     MOVLB 0x0
0933  0859     MOVF state, W
0934  3A00     XORLW 0x0
0935  1903     BTFSC STATUS, 0x2
0936  293E     GOTO 0x13E
0937  3A01     XORLW 0x1
0938  1903     BTFSC STATUS, 0x2
0939  291C     GOTO 0x11C
093A  3A03     XORLW 0x3
093B  1903     BTFSC STATUS, 0x2
093C  2922     GOTO 0x122
093D  293E     GOTO 0x13E
62:                {
63:                    case 0:
64:                        //Inizializzazione hardware.
65:                        break;
66:                    case 1:
67:                        //Inizializzazione variabili.
68:                        tmrRcvPkt=0;
091C  0021     MOVLB 0x1
091D  01AB     CLRF tmrRcvPkt
69:                        rtx_flg.val=0;
091E  01A7     CLRF rtx_flg
70:                        tmrCalibration=0;
091F  01A0     CLRF tmrCalibration
0920  01A1     CLRF 0xA1
71:                        break;
0921  0008     RETURN
72:                    case 2:
73:                        //Avvia la calibrazione e la ricezione.
74:                        CC1Strobe(SIDLE);
0922  3036     MOVLW 0x36
0923  3196     MOVLP 0x16
0924  2695     CALL 0x695
0925  3189     MOVLP 0x9
75:                        CC1Strobe(SCAL);
0926  3033     MOVLW 0x33
0927  3196     MOVLP 0x16
0928  2695     CALL 0x695
0929  3189     MOVLP 0x9
76:                        CC1Strobe(SRX);
092A  3034     MOVLW 0x34
092B  3196     MOVLP 0x16
092C  2695     CALL 0x695
092D  3189     MOVLP 0x9
77:                        //Scrittua display.
78:                        RTXUpdateDisplay(UPD_DPY_RST);
092E  3000     MOVLW 0x0
092F  3180     MOVLP 0x0
0930  203F     CALL 0x3F
79:                        break;
80:            	}
0931  0008     RETURN
81:            }
093E  0008     RETURN
82:            
83:            void RTXTick(void)
84:            {
85:            	//Chiama la funzione del supervisore.
86:            	RTXSup();
09B6  318A     MOVLP 0xA
09B7  2237     CALL 0x237
09B8  3189     MOVLP 0x9
87:                //Timer per la calibrazione.
88:                tmrCalibration++;
09B9  3001     MOVLW 0x1
09BA  0021     MOVLB 0x1
09BB  07A0     ADDWF tmrCalibration, F
09BC  3000     MOVLW 0x0
09BD  3DA1     ADDWFC 0xA1, F
89:                if(tmrCalibration>MAX_TMRCALIBRATION)
09BE  3003     MOVLW 0x3
09BF  0221     SUBWF 0xA1, W
09C0  30E9     MOVLW 0xE9
09C1  1903     BTFSC 0x83, 0x2
09C2  0220     SUBWF tmrCalibration, W
09C3  1C03     BTFSS 0x83, 0x0
09C4  29D3     GOTO 0x1D3
90:                {
91:                    tmrCalibration=0;
09C5  01A0     CLRF tmrCalibration
09C6  01A1     CLRF 0xA1
92:                    CC1Strobe(SIDLE);
09C7  3036     MOVLW 0x36
09C8  3196     MOVLP 0x16
09C9  2695     CALL 0x695
09CA  3189     MOVLP 0x9
93:                    CC1Strobe(SCAL);
09CB  3033     MOVLW 0x33
09CC  3196     MOVLP 0x16
09CD  2695     CALL 0x695
09CE  3189     MOVLP 0x9
94:                    CC1Strobe(SFRX);
09CF  303A     MOVLW 0x3A
09D0  3196     MOVLP 0x16
09D1  2695     CALL 0x695
09D2  3189     MOVLP 0x9
95:                }
96:            		
97:                //Timer di attesa per la ricezione della risposta.
98:                if(tmrRcvPkt)
09D3  0021     MOVLB 0x1
09D4  082B     MOVF tmrRcvPkt, W
09D5  1903     BTFSC 0x83, 0x2
09D6  0008     RETURN
99:                {
100:                   tmrRcvPkt--;
09D7  3001     MOVLW 0x1
09D8  02AB     SUBWF tmrRcvPkt, F
101:                   if(!(tmrRcvPkt))
09D9  08AB     MOVF tmrRcvPkt, F
09DA  1D03     BTFSS 0x83, 0x2
09DB  0008     RETURN
102:                       RTXSendPgm();  //Se il timeout è scaduto, trasmette di nuovo il pacchetto di programmazione.
09DC  3197     MOVLP 0x17
09DD  2753     CALL 0x753
09DE  0021     MOVLB 0x1
09DF  0008     RETURN
103:               }
104:           }
09E0  308E     MOVLW 0x8E
105:           
106:           void RTXTask(void)
107:           {
108:           
109:               float a,b;
110:           
111:               a=123.456;
0839  30E9     MOVLW 0xE9
083A  0020     MOVLB 0x0
083B  00EA     MOVWF a
083C  30F6     MOVLW 0xF6
083D  00EB     MOVWF 0x6B
083E  3042     MOVLW 0x42
083F  00EC     MOVWF 0x6C
112:               b=a;
0840  086A     MOVF a, W
0841  00E7     MOVWF b
0842  086B     MOVF 0x6B, W
0843  00E8     MOVWF 0x68
0844  086C     MOVF 0x6C, W
0845  00E9     MOVWF 0x69
113:               //Controlla se è stato ricevuto un pacchetto e quindi esegue la lettura dello stesso.
114:               if(!(INGetGDO2()))
0846  180D     BTFSC PORTB, 0x0
0847  0008     RETURN
115:                   RTXReadPkt();
0848  3185     MOVLP 0x5
0849  25BC     CALL 0x5BC
084A  0008     RETURN
116:           }
084B  00FA     MOVWF row
117:           
118:           static void RTXUpdateDisplay(te_RTX_UPD_DPY val)
119:           {
120:               char *p,strTmp[DPY_COL_NUM];
121:               unsigned char i,j,isDec,posDec,maxDigit,offset;
122:               int status;
123:           
124:               //Inizializza i vettori.
125:               for(i=0;i<sizeof(strTitle)/sizeof(char);i++)
003F  0021     MOVLB 0x1
0040  00E5     MOVWF val
0041  01E8     CLRF i
0042  3010     MOVLW 0x10
0043  0268     SUBWF i, W
0044  1803     BTFSC 0x83, 0x0
0045  285A     GOTO 0x5A
0051  3001     MOVLW 0x1
0052  00D5     MOVWF 0xD5
0053  0855     MOVF 0xD5, W
0054  0021     MOVLB 0x1
0055  07E8     ADDWF i, F
0056  3010     MOVLW 0x10
0057  0268     SUBWF i, W
0058  1C03     BTFSS 0x83, 0x0
0059  2846     GOTO 0x46
126:                   strTitle[i]=' ';
0046  3020     MOVLW 0x20
0047  0020     MOVLB 0x0
0048  00D5     MOVWF 0x55
0049  0021     MOVLB 0x1
004A  0868     MOVF i, W
004B  3EB3     ADDLW 0xB3
004C  0086     MOVWF 0x86
004D  0187     CLRF 0x87
004E  0020     MOVLB 0x0
004F  0855     MOVF 0x55, W
0050  0081     MOVWF INDF1
127:               for(i=0;i<sizeof(strTemp)/sizeof(char);i++)
005A  01E8     CLRF 0x68
005B  3010     MOVLW 0x10
005C  0268     SUBWF 0x68, W
005D  1803     BTFSC STATUS, 0x0
005E  2874     GOTO 0x74
006B  3001     MOVLW 0x1
006C  00D5     MOVWF 0x55
006D  0855     MOVF 0x55, W
006E  0021     MOVLB 0x1
006F  07E8     ADDWF i, F
0070  3010     MOVLW 0x10
0071  0268     SUBWF i, W
0072  1C03     BTFSS 0x83, 0x0
0073  285F     GOTO 0x5F
128:                   strTemp[i]=' ';
005F  3020     MOVLW 0x20
0060  0020     MOVLB 0x0
0061  00D5     MOVWF 0x55
0062  0021     MOVLB 0x1
0063  0868     MOVF i, W
0064  3E31     ADDLW 0x31
0065  0086     MOVWF 0x86
0066  3001     MOVLW 0x1
0067  0087     MOVWF 0x87
0068  0020     MOVLB 0x0
0069  0855     MOVF 0x55, W
006A  0081     MOVWF INDF1
129:           
130:               if(val==UPD_DPY_PGM || val==UPD_DPY_PGMDONE)
0074  0865     MOVF 0x65, W
0075  3A02     XORLW 0x2
0076  1903     BTFSC STATUS, 0x2
0077  287C     GOTO 0x7C
0078  0865     MOVF 0x65, W
0079  3A03     XORLW 0x3
007A  1D03     BTFSS STATUS, 0x2
007B  2943     GOTO 0x143
131:               {
132:                   strTitle[1]='P';
007C  3050     MOVLW 0x50
007D  0020     MOVLB 0x0
007E  00D5     MOVWF 0x55
007F  0855     MOVF 0x55, W
0080  0021     MOVLB 0x1
0081  00B4     MOVWF 0xB4
133:                   strTitle[2]='r';
0082  3072     MOVLW 0x72
0083  0020     MOVLB 0x0
0084  00D5     MOVWF 0x55
0085  0855     MOVF 0x55, W
0086  0021     MOVLB 0x1
0087  00B5     MOVWF 0xB5
134:                   strTitle[3]='o';
0088  306F     MOVLW 0x6F
0089  0020     MOVLB 0x0
008A  00D5     MOVWF 0x55
008B  0855     MOVF 0x55, W
008C  0021     MOVLB 0x1
008D  00B6     MOVWF 0xB6
135:                   strTitle[4]='g';
008E  3067     MOVLW 0x67
008F  0020     MOVLB 0x0
0090  00D5     MOVWF 0x55
0091  0855     MOVF 0x55, W
0092  0021     MOVLB 0x1
0093  00B7     MOVWF 0xB7
136:                   strTitle[5]='r';
0094  3072     MOVLW 0x72
0095  0020     MOVLB 0x0
0096  00D5     MOVWF 0x55
0097  0855     MOVF 0x55, W
0098  0021     MOVLB 0x1
0099  00B8     MOVWF 0xB8
137:                   strTitle[6]='a';
009A  3061     MOVLW 0x61
009B  0020     MOVLB 0x0
009C  00D5     MOVWF 0x55
009D  0855     MOVF 0x55, W
009E  0021     MOVLB 0x1
009F  00B9     MOVWF 0xB9
138:                   strTitle[7]='m';
00A0  306D     MOVLW 0x6D
00A1  0020     MOVLB 0x0
00A2  00D5     MOVWF 0x55
00A3  0855     MOVF 0x55, W
00A4  0021     MOVLB 0x1
00A5  00BA     MOVWF 0xBA
139:                   strTitle[8]='m';
00A6  306D     MOVLW 0x6D
00A7  0020     MOVLB 0x0
00A8  00D5     MOVWF 0x55
00A9  0855     MOVF 0x55, W
00AA  0021     MOVLB 0x1
00AB  00BB     MOVWF 0xBB
140:                   strTitle[9]='a';
00AC  3061     MOVLW 0x61
00AD  0020     MOVLB 0x0
00AE  00D5     MOVWF 0x55
00AF  0855     MOVF 0x55, W
00B0  0021     MOVLB 0x1
00B1  00BC     MOVWF 0xBC
141:                   strTitle[10]='z';
00B2  307A     MOVLW 0x7A
00B3  0020     MOVLB 0x0
00B4  00D5     MOVWF 0x55
00B5  0855     MOVF 0x55, W
00B6  0021     MOVLB 0x1
00B7  00BD     MOVWF 0xBD
142:                   strTitle[11]='i';
00B8  3069     MOVLW 0x69
00B9  0020     MOVLB 0x0
00BA  00D5     MOVWF 0x55
00BB  0855     MOVF 0x55, W
00BC  0021     MOVLB 0x1
00BD  00BE     MOVWF 0xBE
143:                   strTitle[12]='o';
00BE  306F     MOVLW 0x6F
00BF  0020     MOVLB 0x0
00C0  00D5     MOVWF 0x55
00C1  0855     MOVF 0x55, W
00C2  0021     MOVLB 0x1
00C3  00BF     MOVWF 0xBF
144:                   strTitle[13]='n';
00C4  306E     MOVLW 0x6E
00C5  0020     MOVLB 0x0
00C6  00D5     MOVWF 0x55
00C7  0855     MOVF 0x55, W
00C8  0021     MOVLB 0x1
00C9  00C0     MOVWF 0xC0
145:                   strTitle[14]='e';
00CA  3065     MOVLW 0x65
00CB  0020     MOVLB 0x0
00CC  00D5     MOVWF 0x55
00CD  0855     MOVF 0x55, W
00CE  0021     MOVLB 0x1
00CF  00C1     MOVWF 0xC1
146:                   DPYSendStr(0,(DPY_COL_NUM-sizeof(strTitle))/2,strTitle,sizeof(strTitle)/sizeof(char));
00D0  0020     MOVLB 0x0
00D1  01A0     CLRF __pcstackBANK0
00D2  30B3     MOVLW 0xB3
00D3  00A1     MOVWF data
00D4  3000     MOVLW 0x0
00D5  00A2     MOVWF i
00D6  3010     MOVLW 0x10
00D7  00D5     MOVWF 0x55
00D8  0855     MOVF 0x55, W
00D9  00A3     MOVWF f2
00DA  3000     MOVLW 0x0
00DB  318C     MOVLP 0xC
00DC  2416     CALL 0x416
00DD  3180     MOVLP 0x0
147:                   strTemp[5]='I';
00DE  3049     MOVLW 0x49
00DF  0020     MOVLB 0x0
00E0  00D5     MOVWF 0x55
00E1  0855     MOVF 0x55, W
00E2  0022     MOVLB 0x2
00E3  00B6     MOVWF 0x136
148:                   strTemp[6]='D';
00E4  3044     MOVLW 0x44
00E5  0020     MOVLB 0x0
00E6  00D5     MOVWF 0x55
00E7  0855     MOVF 0x55, W
00E8  0022     MOVLB 0x2
00E9  00B7     MOVWF 0x137
149:                   strTemp[7]=':';
00EA  303A     MOVLW 0x3A
00EB  0020     MOVLB 0x0
00EC  00D5     MOVWF 0x55
00ED  0855     MOVF 0x55, W
00EE  0022     MOVLB 0x2
00EF  00B8     MOVWF 0x138
150:                   if(val==UPD_DPY_PGM)
00F0  0021     MOVLB 0x1
00F1  0865     MOVF val, W
00F2  3A02     XORLW 0x2
00F3  1D03     BTFSS 0x83, 0x2
00F4  2906     GOTO 0x106
151:                   {
152:                       strTemp[9]='?';
00F5  303F     MOVLW 0x3F
00F6  0020     MOVLB 0x0
00F7  00D5     MOVWF 0x55
00F8  0855     MOVF 0x55, W
00F9  0022     MOVLB 0x2
00FA  00BA     MOVWF 0x13A
153:                       strTemp[10]='?';
00FB  303F     MOVLW 0x3F
00FC  0020     MOVLB 0x0
00FD  00D5     MOVWF 0x55
00FE  0855     MOVF 0x55, W
00FF  0022     MOVLB 0x2
0100  00BB     MOVWF 0x13B
154:                       strTemp[11]='?';
0101  303F     MOVLW 0x3F
0102  0020     MOVLB 0x0
0103  00D5     MOVWF 0x55
0104  0855     MOVF 0x55, W
0105  2933     GOTO 0x133
155:                   }
156:                   else
157:                   {
158:                       itoa(p,pgm_cfg.sensId,10);
0106  0021     MOVLB 0x1
0107  0846     MOVF 0xC6, W
0108  0020     MOVLB 0x0
0109  00D5     MOVWF 0x55
010A  01D6     CLRF 0x56
010B  0855     MOVF 0x55, W
010C  00A8     MOVWF src
010D  0856     MOVF 0x56, W
010E  00A9     MOVWF dividend
010F  300A     MOVLW 0xA
0110  00AA     MOVWF exp
0111  3000     MOVLW 0x0
0112  00AB     MOVWF f3_as_product
0113  0021     MOVLB 0x1
0114  0867     MOVF p, W
0115  3189     MOVLP 0x9
0116  218D     CALL 0x18D
0117  3180     MOVLP 0x0
159:                       strTemp[9]=(*(p));
0118  0021     MOVLB 0x1
0119  0867     MOVF p, W
011A  0086     MOVWF 0x86
011B  3001     MOVLW 0x1
011C  0087     MOVWF 0x87
011D  0801     MOVF 0x81, W
011E  0020     MOVLB 0x0
011F  00D5     MOVWF 0x55
0120  0855     MOVF 0x55, W
0121  0022     MOVLB 0x2
0122  00BA     MOVWF 0x13A
160:                       strTemp[10]=(*(p+1));
0123  0021     MOVLB 0x1
0124  0867     MOVF p, W
0125  0086     MOVWF 0x86
0126  3001     MOVLW 0x1
0127  0087     MOVWF 0x87
0128  3001     MOVLW 0x1
0129  3F41     MOVIW [1]FSR1
012A  0022     MOVLB 0x2
012B  00BB     MOVWF 0x13B
161:                       strTemp[11]=(*(p+2));
012C  0021     MOVLB 0x1
012D  0867     MOVF p, W
012E  0086     MOVWF 0x86
012F  3001     MOVLW 0x1
0130  0087     MOVWF 0x87
0131  3001     MOVLW 0x1
0132  3F42     MOVIW [2]FSR1
0133  0022     MOVLB 0x2
0134  00BC     MOVWF 0x13C
162:                   }
163:                   DPYSendStr(1,0,strTemp,sizeof(strTemp)/sizeof(char));
0135  0020     MOVLB 0x0
0136  01A0     CLRF __pcstackBANK0
0137  3031     MOVLW 0x31
0138  00A1     MOVWF data
0139  3001     MOVLW 0x1
013A  00A2     MOVWF i
013B  3010     MOVLW 0x10
013C  00D5     MOVWF 0x55
013D  0855     MOVF 0x55, W
013E  00A3     MOVWF f2
013F  3001     MOVLW 0x1
0140  318C     MOVLP 0xC
0141  2416     CALL 0x416
164:               }
0142  0008     RETURN
165:               else
166:               {
167:                   strTitle[2]='T';
0143  3054     MOVLW 0x54
0144  0020     MOVLB 0x0
0145  00D5     MOVWF 0x55
0146  0855     MOVF 0x55, W
0147  0021     MOVLB 0x1
0148  00B5     MOVWF 0xB5
168:                   strTitle[3]='e';
0149  3065     MOVLW 0x65
014A  0020     MOVLB 0x0
014B  00D5     MOVWF 0x55
014C  0855     MOVF 0x55, W
014D  0021     MOVLB 0x1
014E  00B6     MOVWF 0xB6
169:                   strTitle[4]='m';
014F  306D     MOVLW 0x6D
0150  0020     MOVLB 0x0
0151  00D5     MOVWF 0x55
0152  0855     MOVF 0x55, W
0153  0021     MOVLB 0x1
0154  00B7     MOVWF 0xB7
170:                   strTitle[5]='p';
0155  3070     MOVLW 0x70
0156  0020     MOVLB 0x0
0157  00D5     MOVWF 0x55
0158  0855     MOVF 0x55, W
0159  0021     MOVLB 0x1
015A  00B8     MOVWF 0xB8
171:                   strTitle[6]='e';
015B  3065     MOVLW 0x65
015C  0020     MOVLB 0x0
015D  00D5     MOVWF 0x55
015E  0855     MOVF 0x55, W
015F  0021     MOVLB 0x1
0160  00B9     MOVWF 0xB9
172:                   strTitle[7]='r';
0161  3072     MOVLW 0x72
0162  0020     MOVLB 0x0
0163  00D5     MOVWF 0x55
0164  0855     MOVF 0x55, W
0165  0021     MOVLB 0x1
0166  00BA     MOVWF 0xBA
173:                   strTitle[8]='a';
0167  3061     MOVLW 0x61
0168  0020     MOVLB 0x0
0169  00D5     MOVWF 0x55
016A  0855     MOVF 0x55, W
016B  0021     MOVLB 0x1
016C  00BB     MOVWF 0xBB
174:                   strTitle[9]='t';
016D  3074     MOVLW 0x74
016E  0020     MOVLB 0x0
016F  00D5     MOVWF 0x55
0170  0855     MOVF 0x55, W
0171  0021     MOVLB 0x1
0172  00BC     MOVWF 0xBC
175:                   strTitle[10]='u';
0173  3075     MOVLW 0x75
0174  0020     MOVLB 0x0
0175  00D5     MOVWF 0x55
0176  0855     MOVF 0x55, W
0177  0021     MOVLB 0x1
0178  00BD     MOVWF 0xBD
176:                   strTitle[11]='r';
0179  3072     MOVLW 0x72
017A  0020     MOVLB 0x0
017B  00D5     MOVWF 0x55
017C  0855     MOVF 0x55, W
017D  0021     MOVLB 0x1
017E  00BE     MOVWF 0xBE
177:                   strTitle[12]='a';
017F  3061     MOVLW 0x61
0180  0020     MOVLB 0x0
0181  00D5     MOVWF 0x55
0182  0855     MOVF 0x55, W
0183  0021     MOVLB 0x1
0184  00BF     MOVWF 0xBF
178:                   strTitle[13]=':';
0185  303A     MOVLW 0x3A
0186  0020     MOVLB 0x0
0187  00D5     MOVWF 0x55
0188  0855     MOVF 0x55, W
0189  0021     MOVLB 0x1
018A  00C0     MOVWF 0xC0
179:                   DPYSendStr(0,(DPY_COL_NUM-sizeof(strTitle))/2,strTitle,sizeof(strTitle)/sizeof(char));
018B  0020     MOVLB 0x0
018C  01A0     CLRF __pcstackBANK0
018D  30B3     MOVLW 0xB3
018E  00A1     MOVWF data
018F  3000     MOVLW 0x0
0190  00A2     MOVWF i
0191  3010     MOVLW 0x10
0192  00D5     MOVWF 0x55
0193  0855     MOVF 0x55, W
0194  00A3     MOVWF f2
0195  3000     MOVLW 0x0
0196  318C     MOVLP 0xC
0197  2416     CALL 0x416
0198  3180     MOVLP 0x0
180:                   if(val==UPD_DPY_TEMP)
0199  0021     MOVLB 0x1
019A  0865     MOVF val, W
019B  3A01     XORLW 0x1
019C  1D03     BTFSS 0x83, 0x2
019D  2AAE     GOTO 0x2AE
181:                   {
182:                       p=ftoa(temp,(&(status)));
019E  084B     MOVF temp, W
019F  0020     MOVLB 0x0
01A0  00C7     MOVWF f
01A1  0021     MOVLB 0x1
01A2  084C     MOVF 0xCC, W
01A3  0020     MOVLB 0x0
01A4  00C8     MOVWF 0x48
01A5  0021     MOVLB 0x1
01A6  084D     MOVF 0xCD, W
01A7  0020     MOVLB 0x0
01A8  00C9     MOVWF 0x49
01A9  30DF     MOVLW 0xDF
01AA  00D5     MOVWF 0x55
01AB  0855     MOVF 0x55, W
01AC  00CA     MOVWF 0x4A
01AD  318F     MOVLP 0xF
01AE  275D     CALL 0x75D
01AF  3180     MOVLP 0x0
01B0  0020     MOVLB 0x0
01B1  00D6     MOVWF 0x56
01B2  0856     MOVF 0x56, W
01B3  0021     MOVLB 0x1
01B4  00E7     MOVWF p
183:                       //Ricava il vettore e la sua lunghezza.
184:                       isDec=0;
01B5  01E2     CLRF isDec
185:                       for(i=0;i<sizeof(strTmp)/sizeof(char);i++)
01B6  01E8     CLRF i
01B7  3010     MOVLW 0x10
01B8  0268     SUBWF i, W
01B9  1803     BTFSC 0x83, 0x0
01BA  2A1A     GOTO 0x21A
0211  3001     MOVLW 0x1
0212  00D5     MOVWF 0xD5
0213  0855     MOVF 0xD5, W
0214  0021     MOVLB 0x1
0215  07E8     ADDWF i, F
0216  3010     MOVLW 0x10
0217  0268     SUBWF i, W
0218  1C03     BTFSS 0x83, 0x0
0219  29BB     GOTO 0x1BB
186:                       {
187:                           //Controlla la posizione della virgola.
188:                           if((*(p+i))=='.')
01BB  0868     MOVF i, W
01BC  0767     ADDWF p, W
01BD  0020     MOVLB 0x0
01BE  00D5     MOVWF 0x55
01BF  0855     MOVF 0x55, W
01C0  0086     MOVWF FSR1
01C1  3001     MOVLW 0x1
01C2  0087     MOVWF FSR1H
01C3  0801     MOVF INDF1, W
01C4  3A2E     XORLW 0x2E
01C5  1D03     BTFSS STATUS, 0x2
01C6  29D0     GOTO 0x1D0
189:                           {
190:                               isDec=1;
01C7  0021     MOVLB 0x1
01C8  01E2     CLRF isDec
01C9  0AE2     INCF isDec, F
191:                               posDec=i;
01CA  0868     MOVF i, W
01CB  0020     MOVLB 0x0
01CC  00D5     MOVWF 0x55
01CD  0855     MOVF 0x55, W
01CE  0021     MOVLB 0x1
01CF  00E1     MOVWF posDec
192:                           }
193:                           //Calcola il numero di cifre decimali.
194:                           if(isDec)
01D0  0021     MOVLB 0x1
01D1  0862     MOVF isDec, W
01D2  1903     BTFSC 0x83, 0x2
01D3  29F2     GOTO 0x1F2
195:                           {
196:                               if((i-posDec)>MAX_DECNUM)
01D4  0861     MOVF posDec, W
01D5  0020     MOVLB 0x0
01D6  00D5     MOVWF 0x55
01D7  01D6     CLRF 0x56
01D8  09D5     COMF 0x55, F
01D9  09D6     COMF 0x56, F
01DA  0AD5     INCF 0x55, F
01DB  1903     BTFSC STATUS, 0x2
01DC  0AD6     INCF 0x56, F
01DD  0021     MOVLB 0x1
01DE  0868     MOVF i, W
01DF  0020     MOVLB 0x0
01E0  0755     ADDWF 0x55, W
01E1  00D7     MOVWF 0x57
01E2  0856     MOVF 0x56, W
01E3  1803     BTFSC STATUS, 0x0
01E4  0A56     INCF 0x56, W
01E5  00D8     MOVWF 0x58
01E6  0858     MOVF 0x58, W
01E7  3A80     XORLW 0x80
01E8  00FF     MOVWF 0x7F
01E9  3080     MOVLW 0x80
01EA  027F     SUBWF 0x7F, W
01EB  1D03     BTFSS STATUS, 0x2
01EC  29EF     GOTO 0x1EF
01ED  3003     MOVLW 0x3
01EE  0257     SUBWF 0x57, W
01EF  1803     BTFSC STATUS, 0x0
01F0  2A1A     GOTO 0x21A
197:                                   break;
01F1  0021     MOVLB 0x1
198:                           }
199:                           //Controlla se è arrivato al carattere di fine stringa.
200:                           if((*(p+i))==0x00)
01F2  0021     MOVLB 0x1
01F3  0868     MOVF i, W
01F4  0767     ADDWF p, W
01F5  0020     MOVLB 0x0
01F6  00D5     MOVWF 0x55
01F7  0855     MOVF 0x55, W
01F8  0086     MOVWF FSR1
01F9  3001     MOVLW 0x1
01FA  0087     MOVWF FSR1H
01FB  0881     MOVF INDF1, F
01FC  1903     BTFSC STATUS, 0x2
01FD  2A1A     GOTO 0x21A
201:                               break;
202:                           //Copia i caratteri.
203:                           strTmp[i]=(*(p+i));
01FE  0021     MOVLB 0x1
01FF  0868     MOVF i, W
0200  0767     ADDWF p, W
0201  0020     MOVLB 0x0
0202  00D5     MOVWF 0x55
0203  0855     MOVF 0x55, W
0204  0086     MOVWF FSR1
0205  3001     MOVLW 0x1
0206  0087     MOVWF FSR1H
0207  0801     MOVF INDF1, W
0208  00D6     MOVWF 0x56
0209  0021     MOVLB 0x1
020A  0868     MOVF i, W
020B  3ECF     ADDLW 0xCF
020C  0086     MOVWF 0x86
020D  0187     CLRF 0x87
020E  0020     MOVLB 0x0
020F  0856     MOVF 0x56, W
0210  0081     MOVWF INDF1
204:                       }
205:           
206:                       //Calcola il massimo numero di cifre scrivibili.
207:                       maxDigit=(DPY_COL_NUM-2);    //I 2 caratteri sono riservati per "°C".
021A  300E     MOVLW 0xE
021B  0020     MOVLB 0x0
021C  00D5     MOVWF 0x55
021D  0855     MOVF 0x55, W
021E  0021     MOVLB 0x1
021F  00E4     MOVWF maxDigit
208:                       if(batt<2.5)
0220  0848     MOVF batt, W
0221  00F1     MOVWF 0xF1
0222  0849     MOVF 0xC9, W
0223  00F2     MOVWF 0xF2
0224  084A     MOVF 0xCA, W
0225  00F3     MOVWF 0xF3
0226  3000     MOVLW 0x0
0227  00F4     MOVWF 0xF4
0228  3020     MOVLW 0x20
0229  00F5     MOVWF 0xF5
022A  3040     MOVLW 0x40
022B  00F6     MOVWF 0xF6
022C  318B     MOVLP 0xB
022D  2358     CALL 0x358
022E  3180     MOVLP 0x0
022F  1803     BTFSC 0x83, 0x0
0230  2A37     GOTO 0x237
209:                           maxDigit=(DPY_COL_NUM-3);    //I 3 caratteri sono riservati per "°C B".
0231  300D     MOVLW 0xD
0232  0020     MOVLB 0x0
0233  00D5     MOVWF 0x55
0234  0855     MOVF 0x55, W
0235  0021     MOVLB 0x1
0236  00E4     MOVWF maxDigit
210:           
211:                       //Controlla il massimo numero di cifre scrivibili.
212:                       if(i>=maxDigit)
0237  0021     MOVLB 0x1
0238  0864     MOVF maxDigit, W
0239  0268     SUBWF i, W
023A  1C03     BTFSS 0x83, 0x0
023B  2A43     GOTO 0x243
213:                           i=maxDigit-1;
023C  0864     MOVF maxDigit, W
023D  3EFF     ADDLW 0xFF
023E  0020     MOVLB 0x0
023F  00D5     MOVWF 0x55
0240  0855     MOVF 0x55, W
0241  0021     MOVLB 0x1
0242  00E8     MOVWF i
214:           
215:                       //Copia i valori in modo che siano centrati sul display.
216:                       offset=(maxDigit-i)/2;
0243  3002     MOVLW 0x2
0244  00F1     MOVWF 0xF1
0245  3000     MOVLW 0x0
0246  00F2     MOVWF 0xF2
0247  0868     MOVF i, W
0248  0020     MOVLB 0x0
0249  00D5     MOVWF 0x55
024A  01D6     CLRF 0x56
024B  09D5     COMF 0x55, F
024C  09D6     COMF 0x56, F
024D  0AD5     INCF 0x55, F
024E  1903     BTFSC STATUS, 0x2
024F  0AD6     INCF 0x56, F
0250  0021     MOVLB 0x1
0251  0864     MOVF maxDigit, W
0252  0020     MOVLB 0x0
0253  0755     ADDWF 0x55, W
0254  00F3     MOVWF multiplicand
0255  0856     MOVF 0x56, W
0256  1803     BTFSC STATUS, 0x0
0257  0A56     INCF 0x56, W
0258  00F4     MOVWF ff2
0259  318D     MOVLP 0xD
025A  2500     CALL 0x500
025B  3180     MOVLP 0x0
025C  0871     MOVF multiplier, W
025D  0020     MOVLB 0x0
025E  00D7     MOVWF 0x57
025F  0857     MOVF 0x57, W
0260  0021     MOVLB 0x1
0261  00E3     MOVWF offset
217:                       for(j=0;j<i;j++)
0262  01E6     CLRF j
0263  0868     MOVF i, W
0264  0266     SUBWF j, W
0265  1803     BTFSC 0x83, 0x0
0266  2A7E     GOTO 0x27E
0278  3001     MOVLW 0x1
0279  00D5     MOVWF 0xD5
027A  0855     MOVF 0xD5, W
027B  0021     MOVLB 0x1
027C  07E6     ADDWF j, F
027D  2A63     GOTO 0x263
218:                           strTemp[j+offset]=strTmp[j];
0267  0866     MOVF j, W
0268  3ECF     ADDLW 0xCF
0269  0086     MOVWF 0x86
026A  0187     CLRF 0x87
026B  0801     MOVF 0x81, W
026C  0020     MOVLB 0x0
026D  00D5     MOVWF 0x55
026E  0021     MOVLB 0x1
026F  0866     MOVF j, W
0270  0763     ADDWF offset, W
0271  3E31     ADDLW 0x31
0272  0086     MOVWF 0x86
0273  3001     MOVLW 0x1
0274  0087     MOVWF 0x87
0275  0020     MOVLB 0x0
0276  0855     MOVF 0x55, W
0277  0081     MOVWF INDF1
219:           
220:                       //Setta gli altri caratteri.
221:                       strTemp[j+offset]=0b11011111;     //Simbolo "°"
027E  30DF     MOVLW 0xDF
027F  0020     MOVLB 0x0
0280  00D5     MOVWF 0x55
0281  0021     MOVLB 0x1
0282  0866     MOVF j, W
0283  0763     ADDWF offset, W
0284  3E31     ADDLW 0x31
0285  0086     MOVWF 0x86
0286  3001     MOVLW 0x1
0287  0087     MOVWF 0x87
0288  0020     MOVLB 0x0
0289  0855     MOVF 0x55, W
028A  0081     MOVWF INDF1
222:                       strTemp[j+offset+1]='C';
028B  3043     MOVLW 0x43
028C  00D5     MOVWF 0x55
028D  0021     MOVLB 0x1
028E  0863     MOVF offset, W
028F  0766     ADDWF j, W
0290  0020     MOVLB 0x0
0291  00D6     MOVWF 0x56
0292  0A56     INCF 0x56, W
0293  3E31     ADDLW 0x31
0294  0086     MOVWF FSR1
0295  3001     MOVLW 0x1
0296  0087     MOVWF FSR1H
0297  0855     MOVF 0x55, W
0298  0081     MOVWF INDF1
223:                       if(batt<2.5)
0299  0021     MOVLB 0x1
029A  0848     MOVF batt, W
029B  00F1     MOVWF 0xF1
029C  0849     MOVF 0xC9, W
029D  00F2     MOVWF 0xF2
029E  084A     MOVF 0xCA, W
029F  00F3     MOVWF 0xF3
02A0  3000     MOVLW 0x0
02A1  00F4     MOVWF 0xF4
02A2  3020     MOVLW 0x20
02A3  00F5     MOVWF 0xF5
02A4  3040     MOVLW 0x40
02A5  00F6     MOVWF 0xF6
02A6  318B     MOVLP 0xB
02A7  2358     CALL 0x358
02A8  3180     MOVLP 0x0
02A9  1803     BTFSC 0x83, 0x0
02AA  2ADC     GOTO 0x2DC
224:                           strTemp[sizeof(strTemp)/sizeof(char)-1]=0x00;
02AB  0022     MOVLB 0x2
02AC  01C0     CLRF 0x140
225:                   }
02AD  2ADC     GOTO 0x2DC
226:                   else if(val==UPD_DPY_RST)
02AE  0021     MOVLB 0x1
02AF  08E5     MOVF val, F
02B0  1D03     BTFSS 0x83, 0x2
02B1  2ADC     GOTO 0x2DC
227:                   {
228:                       strTemp[5]='?';
02B2  303F     MOVLW 0x3F
02B3  0020     MOVLB 0x0
02B4  00D5     MOVWF 0x55
02B5  0855     MOVF 0x55, W
02B6  0022     MOVLB 0x2
02B7  00B6     MOVWF 0x136
229:                       strTemp[6]='?';
02B8  303F     MOVLW 0x3F
02B9  0020     MOVLB 0x0
02BA  00D5     MOVWF 0x55
02BB  0855     MOVF 0x55, W
02BC  0022     MOVLB 0x2
02BD  00B7     MOVWF 0x137
230:                       strTemp[7]='.';
02BE  302E     MOVLW 0x2E
02BF  0020     MOVLB 0x0
02C0  00D5     MOVWF 0x55
02C1  0855     MOVF 0x55, W
02C2  0022     MOVLB 0x2
02C3  00B8     MOVWF 0x138
231:                       strTemp[8]='?';
02C4  303F     MOVLW 0x3F
02C5  0020     MOVLB 0x0
02C6  00D5     MOVWF 0x55
02C7  0855     MOVF 0x55, W
02C8  0022     MOVLB 0x2
02C9  00B9     MOVWF 0x139
232:                       strTemp[9]='?';
02CA  303F     MOVLW 0x3F
02CB  0020     MOVLB 0x0
02CC  00D5     MOVWF 0x55
02CD  0855     MOVF 0x55, W
02CE  0022     MOVLB 0x2
02CF  00BA     MOVWF 0x13A
233:                       strTemp[10]=0b11011111;     //Simbolo "°"
02D0  30DF     MOVLW 0xDF
02D1  0020     MOVLB 0x0
02D2  00D5     MOVWF 0x55
02D3  0855     MOVF 0x55, W
02D4  0022     MOVLB 0x2
02D5  00BB     MOVWF 0x13B
234:                       strTemp[11]='C';
02D6  3043     MOVLW 0x43
02D7  0020     MOVLB 0x0
02D8  00D5     MOVWF 0x55
02D9  0855     MOVF 0x55, W
02DA  0022     MOVLB 0x2
02DB  00BC     MOVWF 0x13C
235:                   }
236:                   DPYSendStr(1,0,strTemp,sizeof(strTemp)/sizeof(char));
02DC  0020     MOVLB 0x0
02DD  01A0     CLRF __pcstackBANK0
02DE  3031     MOVLW 0x31
02DF  00A1     MOVWF data
02E0  3001     MOVLW 0x1
02E1  00A2     MOVWF i
02E2  3010     MOVLW 0x10
02E3  00D5     MOVWF 0x55
02E4  0855     MOVF 0x55, W
02E5  00A3     MOVWF f2
02E6  3001     MOVLW 0x1
02E7  318C     MOVLP 0xC
02E8  2416     CALL 0x416
02E9  0008     RETURN
237:               }
238:           }
02EA  0020     MOVLB 0x0
239:           
240:           static void RTXSup(void)
241:           {
242:               //Legge lo stato e attiva l'operazione appropriata.
243:               CC1Read(ADDR_CC1_STA,(&(sta)),1);
0A37  307C     MOVLW 0x7C
0A38  0020     MOVLB 0x0
0A39  00A0     MOVWF __pcstackBANK0
0A3A  3000     MOVLW 0x0
0A3B  00A1     MOVWF data
0A3C  01A2     CLRF i
0A3D  0AA2     INCF i, F
0A3E  3035     MOVLW 0x35
0A3F  3188     MOVLP 0x8
0A40  20CF     CALL 0xCF
0A41  318A     MOVLP 0xA
244:           
245:               //Operazione da eseguire in seguito alla lettura dello stato.
246:               switch(sta)
0A42  2A57     GOTO 0x257
0A57  087C     MOVF sta, W
0A58  3A01     XORLW 0x1
0A59  1903     BTFSC STATUS, 0x2
0A5A  2A43     GOTO 0x243
0A5B  3A10     XORLW 0x10
0A5C  1903     BTFSC STATUS, 0x2
0A5D  2A47     GOTO 0x247
0A5E  3A07     XORLW 0x7
0A5F  1903     BTFSC STATUS, 0x2
0A60  2A4F     GOTO 0x24F
0A61  2A62     GOTO 0x262
247:               {
248:                   case IDLE:
249:                       CC1Strobe(SRX);
0A43  3034     MOVLW 0x34
0A44  3196     MOVLP 0x16
0A45  2695     CALL 0x695
250:                       break;
0A46  0008     RETURN
251:                   case RXFIFO_OVERFLOW:
252:                       CC1Strobe(SFRX);
0A47  303A     MOVLW 0x3A
0A48  3196     MOVLP 0x16
0A49  2695     CALL 0x695
0A4A  318A     MOVLP 0xA
253:                       CC1Strobe(SRX);
0A4B  3034     MOVLW 0x34
0A4C  3196     MOVLP 0x16
0A4D  2695     CALL 0x695
254:                       break;
0A4E  0008     RETURN
255:                   case TXFIFO_UNDERFLOW:
256:                       CC1Strobe(SFTX);
0A4F  303B     MOVLW 0x3B
0A50  3196     MOVLP 0x16
0A51  2695     CALL 0x695
0A52  318A     MOVLP 0xA
257:                       CC1Strobe(SRX);
0A53  3034     MOVLW 0x34
0A54  3196     MOVLP 0x16
0A55  2695     CALL 0x695
258:                       break;
259:               }
0A56  0008     RETURN
260:           }
0A62  0008     RETURN
261:           
262:           static void RTXSndPkt(unsigned char *src,unsigned char len)
263:           {
264:               //Legge lo stato e attende che il CC1101 è in idle o in ricezione.
265:               do
266:               {
267:                       CLRWDT();
0DA9  0020     MOVLB 0x0
0DAA  00A8     MOVWF src
0DAB  0064     CLRWDT
268:                       CC1Read(ADDR_CC1_STA,(&(sta)),1);
0DAC  307C     MOVLW 0x7C
0DAD  0020     MOVLB 0x0
0DAE  00A0     MOVWF __pcstackBANK0
0DAF  3000     MOVLW 0x0
0DB0  00A1     MOVWF data
0DB1  01A2     CLRF i
0DB2  0AA2     INCF i, F
0DB3  3035     MOVLW 0x35
0DB4  3188     MOVLP 0x8
0DB5  20CF     CALL 0xCF
0DB6  318D     MOVLP 0xD
269:               }
270:               while(!(((sta&0b00011111)==0x0D) || ((sta&0b00011111)==0x01)));
0DB7  301F     MOVLW 0x1F
0DB8  057C     ANDWF sta, W
0DB9  0020     MOVLB 0x0
0DBA  00A6     MOVWF i
0DBB  0826     MOVF i, W
0DBC  3A0D     XORLW 0xD
0DBD  1903     BTFSC STATUS, 0x2
0DBE  2DC6     GOTO 0x5C6
0DBF  301F     MOVLW 0x1F
0DC0  057C     ANDWF sta, W
0DC1  00A6     MOVWF i
0DC2  0826     MOVF i, W
0DC3  3A01     XORLW 0x1
0DC4  1D03     BTFSS STATUS, 0x2
0DC5  2DAB     GOTO 0x5AB
271:               //Setta lo stato di idle.
272:               CC1Strobe(SIDLE);
0DC6  3036     MOVLW 0x36
0DC7  3196     MOVLP 0x16
0DC8  2695     CALL 0x695
0DC9  318D     MOVLP 0xD
273:               CC1Read(ADDR_CC1_BYRX,(&(numRxByte)),1);
0DCA  306F     MOVLW 0x6F
0DCB  0020     MOVLB 0x0
0DCC  00A0     MOVWF __pcstackBANK0
0DCD  3000     MOVLW 0x0
0DCE  00A1     MOVWF data
0DCF  01A2     CLRF i
0DD0  0AA2     INCF i, F
0DD1  303B     MOVLW 0x3B
0DD2  3188     MOVLP 0x8
0DD3  20CF     CALL 0xCF
0DD4  318D     MOVLP 0xD
274:               CC1Read(ADDR_CC1_BYTX,(&(numTxByte)),1);
0DD5  30CE     MOVLW 0xCE
0DD6  0020     MOVLB 0x0
0DD7  00A0     MOVWF __pcstackBANK0
0DD8  3000     MOVLW 0x0
0DD9  00A1     MOVWF data
0DDA  01A2     CLRF i
0DDB  0AA2     INCF i, F
0DDC  303A     MOVLW 0x3A
0DDD  3188     MOVLP 0x8
0DDE  20CF     CALL 0xCF
0DDF  318D     MOVLP 0xD
275:               //Esegue il flush del TX.
276:               CC1Strobe(SFTX);
0DE0  303B     MOVLW 0x3B
0DE1  3196     MOVLP 0x16
0DE2  2695     CALL 0x695
0DE3  318D     MOVLP 0xD
277:               CC1Read(ADDR_CC1_BYTX,(&(numTxByte)),1);
0DE4  30CE     MOVLW 0xCE
0DE5  0020     MOVLB 0x0
0DE6  00A0     MOVWF __pcstackBANK0
0DE7  3000     MOVLW 0x0
0DE8  00A1     MOVWF data
0DE9  01A2     CLRF i
0DEA  0AA2     INCF i, F
0DEB  303A     MOVLW 0x3A
0DEC  3188     MOVLP 0x8
0DED  20CF     CALL 0xCF
0DEE  318D     MOVLP 0xD
278:               //Carica il buffer di trasmissione.
279:               CC1Write(ADDR_CC1_FIFO,src,len);
0DEF  0020     MOVLB 0x0
0DF0  0828     MOVF src, W
0DF1  00A6     MOVWF i
0DF2  0826     MOVF i, W
0DF3  00F7     MOVWF rs
0DF4  0825     MOVF len, W
0DF5  00A7     MOVWF row
0DF6  0827     MOVF row, W
0DF7  00F8     MOVWF col
0DF8  303F     MOVLW 0x3F
0DF9  3188     MOVLP 0x8
0DFA  204B     CALL 0x4B
0DFB  318D     MOVLP 0xD
280:               //Avvia la trasmissione (terminata la trasmissione il CC1101 passa automaticamente allo stato di ricezione).
281:               CC1Strobe(STX);
0DFC  3035     MOVLW 0x35
0DFD  3196     MOVLP 0x16
0DFE  2695     CALL 0x695
282:           }
0DFF  0008     RETURN
283:           
284:           static void RTXRcvPkt(unsigned char *dst,unsigned char len)
285:           {
286:               //Legge il buffer di ricezione.
287:               CC1Read(ADDR_CC1_FIFO,dst,len);
15F9  0020     MOVLB 0x0
15FA  00A6     MOVWF i
15FB  0826     MOVF i, W
15FC  00A0     MOVWF __pcstackBANK0
15FD  3001     MOVLW 0x1
15FE  00A1     MOVWF data
15FF  087B     MOVF addr, W
1600  00A5     MOVWF len
1601  0825     MOVF len, W
1602  00A2     MOVWF i
1603  303F     MOVLW 0x3F
1604  3188     MOVLP 0x8
1605  20CF     CALL 0xCF
288:           }
1606  0008     RETURN
289:           
290:           void RTXReadPkt(void)
291:           {
292:               float *p;
293:               
294:               //Legge il numero di byte presenti nel FIFO.
295:               CC1Read(ADDR_CC1_BYRX,(&(numRxByte)),1);
05BC  306F     MOVLW 0x6F
296:               while(numRxByte>=PKT_LEN)
05C7  3009     MOVLW 0x9
05C8  0020     MOVLB 0x0
05C9  026F     SUBWF numRxByte, W
05CA  1C03     BTFSS STATUS, 0x0
05CB  0008     RETURN
0688  2DC7     GOTO 0x5C7
297:               {
298:                   CLRWDT();
05CC  0064     CLRWDT
299:                   //Legge un pacchetto.
300:                   RTXRcvPkt(pktRx,PKT_LEN);
05CD  3009     MOVLW 0x9
05CE  0020     MOVLB 0x0
05CF  00E5     MOVWF 0x65
05D0  0865     MOVF 0x65, W
05D1  00FB     MOVWF addr
05D2  3041     MOVLW 0x41
05D3  3195     MOVLP 0x15
05D4  25F9     CALL 0x5F9
05D5  3185     MOVLP 0x5
301:                   //Controlla se è attiva la programmazione.
302:                   if(rtx_flg.pgmonoff)
05D6  0021     MOVLB 0x1
05D7  1D27     BTFSS rtx_flg, 0x2
05D8  2DFD     GOTO 0x5FD
303:                   {
304:                       if((pktRx[0]==pgm_cfg.baseId))  //Controlla se l'id della base corrisponde.
05D9  0847     MOVF 0xC7, W
05DA  0022     MOVLB 0x2
05DB  0641     XORWF pktRx, W
05DC  1D03     BTFSS 0x103, 0x2
05DD  2E7A     GOTO 0x67A
305:                       {
306:                           //Controlla se il pacchetto ricevuto è di programmazione.
307:                           if(pktRx[2]==rPGM)
05DE  0843     MOVF 0x143, W
05DF  3A81     XORLW 0x81
05E0  1D03     BTFSS 0x103, 0x2
05E1  2E7A     GOTO 0x67A
308:                           {
309:                               //Memorizza il nuovo ID del sensore.
310:                               pgm_cfg.sensId=pktRx[1];
05E2  0842     MOVF 0x142, W
05E3  0020     MOVLB 0x0
05E4  00E5     MOVWF 0x65
05E5  0865     MOVF 0x65, W
05E6  0021     MOVLB 0x1
05E7  00C6     MOVWF 0xC6
311:                               PGMWriteNvm();
05E8  3196     MOVLP 0x16
05E9  266F     CALL 0x66F
05EA  3185     MOVLP 0x5
312:                               //Segnala che la programmazione è stata eseguita.
313:                               rtx_flg.pgmDone=1;
05EB  0021     MOVLB 0x1
05EC  14A7     BSF rtx_flg, 0x1
314:                               //Arresta l'invio dei pacchetti di programmazione (è sufficiente arresta il time-out).
315:                               tmrRcvPkt=0;
05ED  01AB     CLRF tmrRcvPkt
316:                               //Cambia la visualizzazione del display.
317:                               RTXUpdateDisplay(UPD_DPY_PGMDONE);
05EE  3003     MOVLW 0x3
05EF  3180     MOVLP 0x0
05F0  203F     CALL 0x3F
05F1  3185     MOVLP 0x5
318:                               //Ritardo di visualizzazione.
319:                               DLYDelay_ms(2000);
05F2  30D0     MOVLW 0xD0
05F3  00F1     MOVWF 0xF1
05F4  3007     MOVLW 0x7
05F5  00F2     MOVWF 0xF2
05F6  3196     MOVLP 0x16
05F7  26ED     CALL 0x6ED
05F8  3185     MOVLP 0x5
320:                               //Chiama la funzione per l'arresto della programmazione.
321:                               RTXPgmOff();
05F9  3195     MOVLP 0x15
05FA  259C     CALL 0x59C
05FB  3185     MOVLP 0x5
322:                           }
323:                       }
324:                   }
05FC  2E7A     GOTO 0x67A
325:                   else
326:                   {
327:                       if((pktRx[0]==pgm_cfg.baseId) && (pktRx[1]==pgm_cfg.sensId))
05FD  0021     MOVLB 0x1
05FE  0847     MOVF 0xC7, W
05FF  0022     MOVLB 0x2
0600  0641     XORWF pktRx, W
0601  1D03     BTFSS 0x103, 0x2
0602  2E7A     GOTO 0x67A
0603  0021     MOVLB 0x1
0604  0846     MOVF 0xC6, W
0605  0022     MOVLB 0x2
0606  0642     XORWF 0x142, W
0607  1D03     BTFSS 0x103, 0x2
0608  2E7A     GOTO 0x67A
328:                       {
329:                           //Controlla se il pacchetto ricevuto è di risposta al dato.
330:                           if(pktRx[2]==DAT)
0609  08C3     MOVF 0x143, F
060A  1D03     BTFSS 0x103, 0x2
060B  2E7A     GOTO 0x67A
331:                           {
332:                               //Memorizza la temperatura.
333:                               p=(&(temp));
060C  30CB     MOVLW 0xCB
060D  0020     MOVLB 0x0
060E  00E5     MOVWF 0x65
060F  0865     MOVF 0x65, W
0610  00E6     MOVWF state
334:                               (*(p))=pktRx[3];
0611  0022     MOVLB 0x2
0612  0844     MOVF 0x144, W
0613  3197     MOVLP 0x17
0614  2739     CALL 0x739
0615  3185     MOVLP 0x5
0616  0020     MOVLB 0x0
0617  0866     MOVF state, W
0618  0086     MOVWF FSR1
0619  0187     CLRF FSR1H
061A  0879     MOVF c, W
061B  3FC0     MOVWI [0]FSR1
061C  087A     MOVF row, W
061D  3FC1     MOVWI [1]FSR1
061E  087B     MOVF addr, W
061F  3FC2     MOVWI [2]FSR1
335:                               (*(p+1))=pktRx[4];
0620  0022     MOVLB 0x2
0621  0845     MOVF 0x145, W
0622  3197     MOVLP 0x17
0623  2739     CALL 0x739
0624  3185     MOVLP 0x5
0625  0020     MOVLB 0x0
0626  0866     MOVF state, W
0627  3E03     ADDLW 0x3
0628  0086     MOVWF FSR1
0629  0187     CLRF FSR1H
062A  0879     MOVF c, W
062B  3FC0     MOVWI [0]FSR1
062C  087A     MOVF row, W
062D  3FC1     MOVWI [1]FSR1
062E  087B     MOVF addr, W
062F  3FC2     MOVWI [2]FSR1
336:                               (*(p+2))=pktRx[5];
0630  0022     MOVLB 0x2
0631  0846     MOVF 0x146, W
0632  3197     MOVLP 0x17
0633  2739     CALL 0x739
0634  3185     MOVLP 0x5
0635  0020     MOVLB 0x0
0636  0866     MOVF state, W
0637  3E06     ADDLW 0x6
0638  0086     MOVWF FSR1
0639  0187     CLRF FSR1H
063A  0879     MOVF c, W
063B  3FC0     MOVWI [0]FSR1
063C  087A     MOVF row, W
063D  3FC1     MOVWI [1]FSR1
063E  087B     MOVF addr, W
063F  3FC2     MOVWI [2]FSR1
337:                               //Memorizza la batteria.
338:                               p=(&(batt));
0640  30C8     MOVLW 0xC8
0641  00E5     MOVWF 0x65
0642  0865     MOVF 0x65, W
0643  00E6     MOVWF state
339:                               (*(p))=pktRx[6];
0644  0022     MOVLB 0x2
0645  0847     MOVF 0x147, W
0646  3197     MOVLP 0x17
0647  2739     CALL 0x739
0648  3185     MOVLP 0x5
0649  0020     MOVLB 0x0
064A  0866     MOVF state, W
064B  0086     MOVWF FSR1
064C  0187     CLRF FSR1H
064D  0879     MOVF c, W
064E  3FC0     MOVWI [0]FSR1
064F  087A     MOVF row, W
0650  3FC1     MOVWI [1]FSR1
0651  087B     MOVF addr, W
0652  3FC2     MOVWI [2]FSR1
340:                               (*(p+1))=pktRx[7];
0653  0022     MOVLB 0x2
0654  0848     MOVF 0x148, W
0655  3197     MOVLP 0x17
0656  2739     CALL 0x739
0657  3185     MOVLP 0x5
0658  0020     MOVLB 0x0
0659  0866     MOVF state, W
065A  3E03     ADDLW 0x3
065B  0086     MOVWF FSR1
065C  0187     CLRF FSR1H
065D  0879     MOVF c, W
065E  3FC0     MOVWI [0]FSR1
065F  087A     MOVF row, W
0660  3FC1     MOVWI [1]FSR1
0661  087B     MOVF addr, W
0662  3FC2     MOVWI [2]FSR1
341:                               (*(p+2))=pktRx[8];
0663  0022     MOVLB 0x2
0664  0849     MOVF 0x149, W
0665  3197     MOVLP 0x17
0666  2739     CALL 0x739
0667  3185     MOVLP 0x5
0668  0020     MOVLB 0x0
0669  0866     MOVF state, W
066A  3E06     ADDLW 0x6
066B  0086     MOVWF FSR1
066C  0187     CLRF FSR1H
066D  0879     MOVF c, W
066E  3FC0     MOVWI [0]FSR1
066F  087A     MOVF row, W
0670  3FC1     MOVWI [1]FSR1
0671  087B     MOVF addr, W
0672  3FC2     MOVWI [2]FSR1
342:                               //Invia la risposta ai dati ricevuti.
343:                               RTXSendRData();
0673  3197     MOVLP 0x17
0674  27E2     CALL 0x7E2
0675  3185     MOVLP 0x5
344:                               //Aggiorna il valore sul display.
345:                               RTXUpdateDisplay(UPD_DPY_TEMP);
0676  3001     MOVLW 0x1
0677  3180     MOVLP 0x0
0678  203F     CALL 0x3F
0679  3185     MOVLP 0x5
346:                           }
347:                       }
348:                   }
349:                   //Legge il numero di byte rimanenti.
350:                   CC1Read(ADDR_CC1_BYRX,(&(numRxByte)),1);
067A  306F     MOVLW 0x6F
067B  0020     MOVLB 0x0
067C  00A0     MOVWF __pcstackBANK0
067D  3000     MOVLW 0x0
067E  00A1     MOVWF data
067F  01A2     CLRF i
0680  0AA2     INCF i, F
0681  303B     MOVLW 0x3B
0682  3188     MOVLP 0x8
0683  20CF     CALL 0xCF
0684  3185     MOVLP 0x5
351:                   //Esegue un controllo sullo stato.
352:                   RTXSup();
0685  318A     MOVLP 0xA
0686  2237     CALL 0x237
0687  3185     MOVLP 0x5
353:               }
354:           }
0689  138B     BCF INTCON, 0x7
355:           
356:           static void RTXSendRData(void)
357:           {
358:               //Crea il pacchetto da inviare.
359:               pktTx[0]=pgm_cfg.sensId;
17E2  0021     MOVLB 0x1
17E3  0846     MOVF 0xC6, W
17E4  0020     MOVLB 0x0
17E5  00A9     MOVWF dividend
17E6  0829     MOVF dividend, W
17E7  0022     MOVLB 0x2
17E8  00CA     MOVWF pktTx
360:               pktTx[1]=pgm_cfg.baseId;
17E9  0021     MOVLB 0x1
17EA  0847     MOVF 0xC7, W
17EB  0020     MOVLB 0x0
17EC  00A9     MOVWF dividend
17ED  0829     MOVF dividend, W
17EE  0022     MOVLB 0x2
17EF  00CB     MOVWF 0x14B
361:               pktTx[2]=rDAT;
17F0  3080     MOVLW 0x80
17F1  0020     MOVLB 0x0
17F2  00A9     MOVWF dividend
17F3  0829     MOVF dividend, W
17F4  0022     MOVLB 0x2
17F5  00CC     MOVWF 0x14C
362:               pktTx[3]=0x00;
17F6  01CD     CLRF 0x14D
363:           //    pktTx[4]=0x00;
364:           //    pktTx[5]=0x00;
365:           //    pktTx[6]=0x00;
366:           //    pktTx[7]=0x00;
367:           //    pktTx[8]=0x00;
368:           
369:               //Invia il pacchetto.
370:               RTXSndPkt(pktTx,PKT_LEN);
17F7  3009     MOVLW 0x9
17F8  0020     MOVLB 0x0
17F9  00A9     MOVWF dividend
17FA  0829     MOVF dividend, W
17FB  00A5     MOVWF len
17FC  304A     MOVLW 0x4A
17FD  318D     MOVLP 0xD
17FE  25A9     CALL 0x5A9
371:           }
17FF  0008     RETURN
372:           
373:           static void RTXSendPgm(void)
374:           {
375:               //Crea il pacchetto da inviare.
376:               pktTx[0]=0;//pgm_cfg.sensId;
1753  0022     MOVLB 0x2
377:               pktTx[1]=pgm_cfg.baseId;
1755  0021     MOVLB 0x1
1756  0847     MOVF 0xC7, W
1757  0020     MOVLB 0x0
1758  00A9     MOVWF dividend
1759  0829     MOVF dividend, W
175A  0022     MOVLB 0x2
175B  00CB     MOVWF 0x14B
378:               pktTx[2]=PGM;
175C  01CC     CLRF 0x14C
175D  0ACC     INCF 0x14C, F
379:               pktTx[3]=0x00;
175E  01CD     CLRF 0x14D
380:           //    pktTx[4]=0x00;
381:           //    pktTx[5]=0x00;
382:           //    pktTx[6]=0x00;
383:           //    pktTx[7]=0x00;
384:           //    pktTx[8]=0x00;
385:           
386:               //Invia il pacchetto.
387:               RTXSndPkt(pktTx,PKT_LEN);
175F  3009     MOVLW 0x9
1760  0020     MOVLB 0x0
1761  00A9     MOVWF dividend
1762  0829     MOVF dividend, W
1763  00A5     MOVWF len
1764  304A     MOVLW 0x4A
1765  318D     MOVLP 0xD
1766  25A9     CALL 0x5A9
388:           
389:               //Avvia il timer per il rinvio del pacchetto.
390:               tmrRcvPkt=TICK_TMRRCVPKT;
1767  300A     MOVLW 0xA
1768  0020     MOVLB 0x0
1769  00A9     MOVWF dividend
176A  0829     MOVF dividend, W
176B  0021     MOVLB 0x1
176C  00AB     MOVWF tmrRcvPkt
391:           }
176D  0008     RETURN
392:           
393:           void RTXPgmOn(void)
394:           {
395:               //Setta il flag.
396:               rtx_flg.pgmonoff=1;
15B4  0021     MOVLB 0x1
15B5  1527     BSF rtx_flg, 0x2
397:               //Avvia la trasmissione di un pacchetto di programmazione.
398:               RTXSendPgm();
15B6  3197     MOVLP 0x17
15B7  2753     CALL 0x753
15B8  3195     MOVLP 0x15
399:               //Cambia la visualizzazione del display.
400:               RTXUpdateDisplay(UPD_DPY_PGM);
15B9  3002     MOVLW 0x2
15BA  3180     MOVLP 0x0
15BB  203F     CALL 0x3F
401:           }
15BC  0008     RETURN
402:           
403:           void RTXPgmOff(void)
404:           {
405:               //Setta il flag.
406:               rtx_flg.pgmonoff=0;
159C  0021     MOVLB 0x1
159D  1127     BCF rtx_flg, 0x2
407:               //Arresta l'invio dei pacchetti di programmazione (è sufficiente arresta il time-out).
408:               tmrRcvPkt=0;
159E  01AB     CLRF tmrRcvPkt
409:               //Cambia la visualizzazione del display.
410:               RTXUpdateDisplay(UPD_DPY_RST);
159F  3000     MOVLW 0x0
15A0  3180     MOVLP 0x0
15A1  203F     CALL 0x3F
411:           }
15A2  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/PGM.h  ---------------------------------------------
1:             
2:             typedef struct _PGM_CFG
3:             {
4:                 unsigned char valChk1;
5:                 unsigned char valChk2;
6:             
7:                 unsigned char menu;
8:                 unsigned char sensId;
9:                 unsigned char baseId;
10:            }ts_PGM_CFG;
11:            
12:            typedef union _PGM_FLG
13:            {
14:                unsigned char val;
15:                struct
16:                {
17:                    unsigned int pgmonoff:1;
18:                    unsigned int evPgmOn:1;
19:                    unsigned int evPgmOff:1;
20:                };
21:            }tu_PGM_FLG;
22:            
23:            tu_PGM_FLG pgm_flg;
24:            ts_PGM_CFG pgm_cfg;
25:            const ts_PGM_CFG nvm_pgm_cfg={0x5C,0xC5,0,0,0};
0829  345C     RETLW 0x5C
26:            
27:            void PGMInit(unsigned char);
28:            void PGMTick(void);
29:            void PGMSelDown(void);
30:            void PGMSelLong(void);
31:            void PGMWriteNvm(void);
32:            void PGMPgmOff(void);
33:            #define PGMGetSensId() pgm_cfg.senorId;
34:            #define PGMGetBaseId() pgm_cfg.baseId;
---  D:/Progetti/Termometro wireless/Firmware/Base.X/PGM.c  ---------------------------------------------
1:             #include <xc.h>
2:             #include "Base.h"
3:             #include "DIN.h"
4:             #include "NVM.h"
5:             #include "OUT.h"
6:             #include "PGM.h"
7:             
8:             #define VAL_EEP_CHECK1      0xC5	//Valore per l'indirizzo di controllo eeprom.
9:             #define VAL_EEP_CHECK2      0x5C	//Valore per l'indirizzo di controllo eeprom.
10:            #define RST_EEP_MENU        0x00	//Valore di reset per il menù.
11:            
12:            #define TICK_TMRPGM         1000        //Tick per il timer di fine programmazione.
13:            
14:            #define mPgmInit() T1CON=0b00000001     //Attiva il timer 1 per ricavare il valore casuale per l'id del sense.
15:            
16:            unsigned short tmrPgm;
17:            
18:            static void PGMReadNvm(void);
19:            static void PGMNvmReset(void);
20:            static void PGMCheckNvm(void);
21:            
22:            void PGMInit(unsigned char state)
23:            {
171F  0020     MOVLB 0x0
24:                switch(state)
1721  2F2F     GOTO 0x72F
172F  0020     MOVLB 0x0
1730  0866     MOVF state, W
1731  3A00     XORLW 0x0
1732  1903     BTFSC STATUS, 0x2
1733  2F22     GOTO 0x722
1734  3A01     XORLW 0x1
1735  1903     BTFSC STATUS, 0x2
1736  2F25     GOTO 0x725
1737  2F38     GOTO 0x738
25:                {
26:                    case 0:
27:                        //Inizializzazione hardware.
28:                        mPgmInit();
1722  3001     MOVLW 0x1
1723  0098     MOVWF T1CON
29:                        break;
1724  0008     RETURN
30:                    case 1:
31:                        //Inizializzazione variabili.
32:                        tmrPgm=0;
1725  0021     MOVLB 0x1
1726  01A4     CLRF tmrPgm
1727  01A5     CLRF 0xA5
33:                        pgm_flg.val=0;
1728  01A6     CLRF pgm_flg
34:                        PGMReadNvm();
1729  3196     MOVLP 0x16
172A  265C     CALL 0x65C
172B  3197     MOVLP 0x17
35:                        PGMCheckNvm();
172C  3195     MOVLP 0x15
172D  25D3     CALL 0x5D3
36:                        break;
37:            //        case 2:
38:            //            //Inizializzazione applicazione.
39:            //            break;
40:                }
172E  0008     RETURN
41:            }	
1738  0008     RETURN
42:            
43:            void PGMTick(void)
44:            {
45:                //Timer di termine programmazione.
46:                if(tmrPgm)
1617  0021     MOVLB 0x1
1618  0825     MOVF 0xA5, W
1619  0424     IORWF tmrPgm, W
161A  1903     BTFSC 0x83, 0x2
161B  0008     RETURN
47:                {
48:                    tmrPgm--;
161C  3001     MOVLW 0x1
161D  02A4     SUBWF tmrPgm, F
161E  3000     MOVLW 0x0
161F  3BA5     SUBWFB 0xA5, F
49:                    if(!(tmrPgm))
1620  0825     MOVF 0xA5, W
1621  0424     IORWF tmrPgm, W
1622  1D03     BTFSS 0x83, 0x2
1623  0008     RETURN
50:                        PGMPgmOff();
1624  3195     MOVLP 0x15
1625  258A     CALL 0x58A
1626  0008     RETURN
51:                }
52:            }
1627  01F3     CLRF 0xF3
53:            
54:            static void PGMReadNvm(void)
55:            {
56:                NVMRead((unsigned short)(&(nvm_pgm_cfg)),(char *)(&(pgm_cfg)),sizeof(ts_PGM_CFG));
165C  3029     MOVLW 0x29
165D  00F8     MOVWF 0xF8
165E  3088     MOVLW 0x88
165F  00F9     MOVWF 0xF9
1660  0878     MOVF 0xF8, W
1661  00F1     MOVWF 0xF1
1662  0879     MOVF 0xF9, W
1663  00F2     MOVWF 0xF2
1664  30C3     MOVLW 0xC3
1665  00FA     MOVWF 0xFA
1666  087A     MOVF 0xFA, W
1667  00F3     MOVWF 0xF3
1668  3005     MOVLW 0x5
1669  00FB     MOVWF 0xFB
166A  087B     MOVF 0xFB, W
166B  00F4     MOVWF 0xF4
166C  3188     MOVLP 0x8
166D  20F3     CALL 0xF3
57:            }	
166E  0008     RETURN
58:            
59:            void PGMWriteNvm(void)
60:            {
61:                NVMWrite((unsigned short)(&(nvm_pgm_cfg)),(char *)(&(pgm_cfg)),sizeof(ts_PGM_CFG));
166F  3029     MOVLW 0x29
1670  00F8     MOVWF 0xF8
1671  3088     MOVLW 0x88
1672  00F9     MOVWF 0xF9
1673  0878     MOVF 0xF8, W
1674  00F1     MOVWF 0xF1
1675  0879     MOVF 0xF9, W
1676  00F2     MOVWF 0xF2
1677  30C3     MOVLW 0xC3
1678  00FA     MOVWF 0xFA
1679  087A     MOVF 0xFA, W
167A  00F3     MOVWF 0xF3
167B  3005     MOVLW 0x5
167C  00FB     MOVWF 0xFB
167D  087B     MOVF 0xFB, W
167E  00F4     MOVWF 0xF4
167F  3186     MOVLP 0x6
1680  2689     CALL 0x689
62:            }
1681  0008     RETURN
63:            
64:            static void PGMCheckNvm(void)
65:            {
66:                if(pgm_cfg.valChk1!=VAL_EEP_CHECK1 || pgm_cfg.valChk2!=VAL_EEP_CHECK2)
15D3  0021     MOVLB 0x1
15D4  0843     MOVF pgm_cfg, W
15D5  3AC5     XORLW 0xC5
15D6  1D03     BTFSS 0x83, 0x2
15D7  2DDC     GOTO 0x5DC
15D8  0844     MOVF 0xC4, W
15D9  3A5C     XORLW 0x5C
15DA  1903     BTFSC 0x83, 0x2
15DB  0008     RETURN
67:                    PGMNvmReset();        //Esegue il reset dei valori.
15DC  3196     MOVLP 0x16
15DD  2682     CALL 0x682
15DE  0008     RETURN
68:            }	
69:            
70:            static void PGMNvmReset(void)
71:            {
72:                //Setta i valori.
73:                pgm_cfg.valChk1=VAL_EEP_CHECK1;
1682  30C5     MOVLW 0xC5
1683  0020     MOVLB 0x0
1684  00E5     MOVWF 0x65
1685  0865     MOVF 0x65, W
1686  0021     MOVLB 0x1
1687  00C3     MOVWF pgm_cfg
74:                pgm_cfg.valChk2=VAL_EEP_CHECK2;
1688  305C     MOVLW 0x5C
1689  0020     MOVLB 0x0
168A  00E5     MOVWF 0x65
168B  0865     MOVF 0x65, W
168C  0021     MOVLB 0x1
168D  00C4     MOVWF 0xC4
75:                pgm_cfg.menu=RST_EEP_MENU;
168E  01C5     CLRF 0xC5
76:                pgm_cfg.sensId=0x00;
168F  01C6     CLRF 0xC6
77:                pgm_cfg.baseId=0x00;
1690  01C7     CLRF 0xC7
78:                //Esegue la scrittura della NVM.
79:                PGMWriteNvm();
1691  3196     MOVLP 0x16
1692  266F     CALL 0x66F
80:                //Esegue un reset del microcontrollore.
81:                RESET();
1693  0001     RESET
82:            }
1694  0008     RETURN
83:            
84:            void PGMPgmOff(void)
85:            {
86:                //Setta il timer.
87:                tmrPgm=0;
158A  0021     MOVLB 0x1
158B  01A4     CLRF tmrPgm
158C  01A5     CLRF 0xA5
88:                //Setta il flag.
89:                pgm_flg.pgmonoff=0;
158D  1026     BCF pgm_flg, 0x0
90:                pgm_flg.evPgmOff=1;
158E  1526     BSF pgm_flg, 0x2
91:            }
158F  0008     RETURN
92:            
93:            void PGMSelDown(void)
94:            {
95:                //Segnala che è stata richiesta la programmazione dall'utente.
96:                pgm_flg.pgmonoff=1;
15C8  0021     MOVLB 0x1
15C9  1426     BSF pgm_flg, 0x0
97:                pgm_flg.evPgmOn=1;
15CA  14A6     BSF pgm_flg, 0x1
98:                //Attiva il led per segnalare che la programmazione è attiva.
99:                OUTSetLEDOn();
15CB  0022     MOVLB 0x2
15CC  138E     BCF LATC, 0x7
100:               //Attiva il timer di programmazione.
101:               tmrPgm=TICK_TMRPGM;
15CD  30E8     MOVLW 0xE8
15CE  0021     MOVLB 0x1
15CF  00A4     MOVWF tmrPgm
15D0  3003     MOVLW 0x3
15D1  00A5     MOVWF 0xA5
102:           }
15D2  0008     RETURN
103:           
104:           void PGMSelLong(void)
105:           {
106:               //Genera il numero casuale.
107:               pgm_cfg.sensId=TMR1L^TMR1H;
15DF  0020     MOVLB 0x0
15E0  0816     MOVF TMR1, W
15E1  0617     XORWF TMR1H, W
15E2  00E5     MOVWF 0x65
15E3  0865     MOVF 0x65, W
15E4  0021     MOVLB 0x1
15E5  00C6     MOVWF 0xC6
108:               //Modifica il valore del menù per segnala che il sense è programmato.
109:               pgm_cfg.menu=0x01;
15E6  01C5     CLRF 0xC5
15E7  0AC5     INCF 0xC5, F
110:               //Esegue la scrittura della NVM.
111:               PGMWriteNvm();
15E8  3196     MOVLP 0x16
15E9  266F     CALL 0x66F
112:           }
15EA  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/OUT.c  ---------------------------------------------
1:             #include <xc.h>
2:             #include "OUT.h"
3:             
4:             #define mInitOut() TRISA&=0b00000000; TRISB&=0b00000111; TRISC&=0b00010000; ANSELA&=0b00000000; ANSELB&=0b00000000; ANSELC&=0b00000000
5:             
6:             void OUTInit(unsigned char sta)
7:             {
16D6  00F2     MOVWF 0xF2
8:                 switch(sta)
16D7  2EE7     GOTO 0x6E7
16E7  0872     MOVF 0xF2, W
16E8  3A00     XORLW 0x0
16E9  1903     BTFSC 0x83, 0x2
16EA  2ED8     GOTO 0x6D8
16EB  2EEC     GOTO 0x6EC
9:                 {
10:                    case 0:
11:                        //Inizializzazione hardware.
12:                        mInitOut();
16D8  0021     MOVLB 0x1
16D9  018C     CLRF TRISA
16DA  3007     MOVLW 0x7
16DB  00F1     MOVWF 0xF1
16DC  0871     MOVF 0xF1, W
16DD  058D     ANDWF TRISB, F
16DE  3010     MOVLW 0x10
16DF  00F1     MOVWF 0xF1
16E0  0871     MOVF 0xF1, W
16E1  058E     ANDWF TRISC, F
16E2  0023     MOVLB 0x3
16E3  018C     CLRF ANSELA
16E4  018D     CLRF ANSELB
16E5  018E     CLRF ANSELC
13:                        break;
14:            //        case 1:
15:            //            //Inizializzazione variabili.
16:            //            break;
17:            //        case 2:
18:            //            //Inizializzazione applicazione.
19:            //            break;
20:                }
16E6  0008     RETURN
21:            }
16EC  0008     RETURN
22:            
23:            void OUTSetHTCDataNibble(unsigned char val)
24:            {
176E  00F2     MOVWF 0x1F2
25:                unsigned char dataToSet=0;
176F  01F3     CLRF 0x1F3
26:                //Vengono considerati solo i primi 4 bit del valore passato.
27:                if(val&0b00000001)
1770  1872     BTFSC 0x1F2, 0x0
28:                    dataToSet|=0b00001000;
1771  15F3     BSF 0x1F3, 0x3
29:                if(val&0b00000010)
1772  18F2     BTFSC 0x1F2, 0x1
30:                    dataToSet|=0b00000100;
1773  1573     BSF 0x1F3, 0x2
31:                if(val&0b00000100)
1774  1972     BTFSC 0x1F2, 0x2
32:                    dataToSet|=0b00000010;
1775  14F3     BSF 0x1F3, 0x1
33:                if(val&0b00001000)
1776  19F2     BTFSC 0x1F2, 0x3
34:                    dataToSet|=0b00000001;
1777  1473     BSF 0x1F3, 0x0
35:            
36:                dataToSet&=0b00001111;
1778  300F     MOVLW 0xF
1779  00F1     MOVWF 0x1F1
177A  0871     MOVF 0x1F1, W
177B  05F3     ANDWF 0x1F3, F
37:                port_DATA|=dataToSet;
177C  0873     MOVF 0x1F3, W
177D  00F1     MOVWF 0x1F1
177E  0871     MOVF 0x1F1, W
177F  0022     MOVLB 0x2
1780  048C     IORWF LATA, F
38:                dataToSet|=0b11110000;
1781  30F0     MOVLW 0xF0
1782  00F1     MOVWF 0x171
1783  0871     MOVF 0x171, W
1784  04F3     IORWF 0x173, F
39:                port_DATA&=dataToSet;
1785  0873     MOVF 0x173, W
1786  00F1     MOVWF 0x171
1787  0871     MOVF 0x171, W
1788  058C     ANDWF LATA, F
40:            }
1789  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/NVM.c  ---------------------------------------------
1:             #include <xc.h>
2:             #include "NVM.h"
3:             
4:             #define mInitNvm() PMCON1=0b00000000
5:             
6:             void NVMInit(unsigned char sta)
7:             {
15BD  00F1     MOVWF 0x171
8:                 switch(sta)
15BE  2DC2     GOTO 0x5C2
15C2  0871     MOVF 0x171, W
15C3  3A00     XORLW 0x0
15C4  1903     BTFSC 0x103, 0x2
15C5  2DBF     GOTO 0x5BF
15C6  2DC7     GOTO 0x5C7
9:                 {
10:                    case 0:
11:                        //Inizializzazione hardware.
12:                        mInitNvm();
15BF  0023     MOVLB 0x3
15C0  0195     CLRF PMCON1
13:                        break;
14:            //        case 1:
15:            //            //Inizializzazione variabili.
16:            //            break;
17:            //        case 2:
18:            //            //Inizializzazione applicazione.
19:            //            break;
20:                }
15C1  0008     RETURN
21:            }
15C7  0008     RETURN
22:            
23:            void NVMRead(unsigned short addr,char *dest,unsigned char len)
24:            {
25:                unsigned char i;
26:            
27:                PMCON1bits.CFGS=0;
08F3  0023     MOVLB 0x3
08F4  1315     BCF PMCON1, 0x6
28:                for(i=0;i<len;i++)
08F5  01F7     CLRF 0x1F7
08F6  0874     MOVF 0x1F4, W
08F7  0277     SUBWF 0x1F7, W
08F8  1803     BTFSC 0x183, 0x0
08F9  0008     RETURN
0914  3001     MOVLW 0x1
0915  00F5     MOVWF 0x1F5
0916  0875     MOVF 0x1F5, W
0917  07F7     ADDWF 0x1F7, F
0918  28F6     GOTO 0xF6
29:                {
30:                    CLRWDT();
08FA  0064     CLRWDT
31:                    PMADR=(addr+i);
08FB  0877     MOVF 0x1F7, W
08FC  0771     ADDWF 0x1F1, W
08FD  00F5     MOVWF 0x1F5
08FE  0872     MOVF 0x1F2, W
08FF  1803     BTFSC 0x183, 0x0
0900  0A72     INCF 0x1F2, W
0901  00F6     MOVWF 0x1F6
0902  0875     MOVF 0x1F5, W
0903  0023     MOVLB 0x3
0904  0091     MOVWF PMADR
0905  0876     MOVF 0x1F6, W
0906  0092     MOVWF PMADRH
32:                    PMCON1bits.RD=1;
0907  1415     BSF PMCON1, 0x0
33:                    while(PMCON1bits.RD);
0908  1815     BTFSC PMCON1, 0x0
0909  2908     GOTO 0x108
34:                    (*(dest+i))=PMDAT;
090A  0813     MOVF PMDAT, W
090B  00F5     MOVWF 0x1F5
090C  0877     MOVF 0x1F7, W
090D  0773     ADDWF 0x1F3, W
090E  00F6     MOVWF 0x1F6
090F  0876     MOVF 0x1F6, W
0910  0086     MOVWF 0x186
0911  0187     CLRF 0x187
0912  0875     MOVF 0x1F5, W
0913  0081     MOVWF 0x181
35:                }
36:            }
0919  0020     MOVLB 0x0
091A  00D9     MOVWF state
37:            
38:            void NVMWrite(unsigned short addr,char *source,unsigned char len)
39:            {
40:                unsigned char i,j,latchAddr;
41:                unsigned short rowAddr,bufTmpRow[0x20];
42:            
43:                INTCONbits.GIE=0;
0689  138B     BCF INTCON, 0x7
44:                PMCON1bits.WREN=1;
068A  0023     MOVLB 0x3
068B  1515     BSF PMCON1, 0x2
45:                PMCON1bits.CFGS=0;
068C  1315     BCF PMCON1, 0x6
46:            
47:                //Azzera gli indici per il puntatore "source".
48:                i=0;
068D  0020     MOVLB 0x0
068E  01E2     CLRF i
49:                //Ricava l'indirizzo di riga e di latch.
50:                rowAddr=(addr&(~(0x001F)));
068F  30E0     MOVLW 0xE0
0690  0571     ANDWF multiplier, W
0691  00E0     MOVWF rowAddr
0692  30FF     MOVLW 0xFF
0693  0572     ANDWF val, W
0694  00E1     MOVWF 0x61
51:                latchAddr=(addr&0x001F);
0695  0871     MOVF multiplier, W
0696  391F     ANDLW 0x1F
0697  00F5     MOVWF product
0698  0875     MOVF product, W
0699  00E3     MOVWF latchAddr
52:                while(i<len)
069A  0874     MOVF ff2, W
069B  0262     SUBWF i, W
069C  1803     BTFSC STATUS, 0x0
069D  2F43     GOTO 0x743
0742  2E9A     GOTO 0x69A
53:                {
54:                    CLRWDT();
069E  0064     CLRWDT
55:            
56:                    //Legge il contenuto della riga.
57:                    for(j=0;j<sizeof(bufTmpRow)/sizeof(unsigned short);j++)
069F  0020     MOVLB 0x0
06A0  01E4     CLRF j
06A1  3020     MOVLW 0x20
06A2  0264     SUBWF j, W
06A3  1803     BTFSC STATUS, 0x0
06A4  2EC9     GOTO 0x6C9
06C0  3001     MOVLW 0x1
06C1  00F5     MOVWF product
06C2  0875     MOVF product, W
06C3  0020     MOVLB 0x0
06C4  07E4     ADDWF j, F
06C5  3020     MOVLW 0x20
06C6  0264     SUBWF j, W
06C7  1C03     BTFSS STATUS, 0x0
06C8  2EA5     GOTO 0x6A5
58:                    {
59:                        CLRWDT();
06A5  0064     CLRWDT
60:                        PMADR=(rowAddr+j);
06A6  0020     MOVLB 0x0
06A7  0864     MOVF j, W
06A8  0760     ADDWF rowAddr, W
06A9  00F5     MOVWF product
06AA  0861     MOVF 0x61, W
06AB  1803     BTFSC STATUS, 0x0
06AC  0A61     INCF 0x61, W
06AD  00F6     MOVWF bf
06AE  0875     MOVF product, W
06AF  0023     MOVLB 0x3
06B0  0091     MOVWF PMADR
06B1  0876     MOVF 0x1F6, W
06B2  0092     MOVWF PMADRH
61:                        PMCON1bits.RD=1;
06B3  1415     BSF PMCON1, 0x0
62:                        while(PMCON1bits.RD);
06B4  1815     BTFSC PMCON1, 0x0
06B5  2EB4     GOTO 0x6B4
63:                        bufTmpRow[j]=PMDAT;
06B6  0020     MOVLB 0x0
06B7  3564     LSLF j, W
06B8  3E20     ADDLW 0x20
06B9  0086     MOVWF FSR1
06BA  0187     CLRF FSR1H
06BB  0023     MOVLB 0x3
06BC  0813     MOVF PMDAT, W
06BD  3FC0     MOVWI [0]FSR1
06BE  0814     MOVF PMDATH, W
06BF  3FC1     MOVWI [1]FSR1
64:                    }
65:            
66:                    //Cancellazione della riga.
67:                    PMCON1bits.FREE=1;
06C9  0023     MOVLB 0x3
06CA  1615     BSF PMCON1, 0x4
68:                    PMADR=rowAddr;
06CB  0020     MOVLB 0x0
06CC  0861     MOVF 0x61, W
06CD  0023     MOVLB 0x3
06CE  0192     CLRF PMADRH
06CF  0792     ADDWF PMADRH, F
06D0  0020     MOVLB 0x0
06D1  0860     MOVF rowAddr, W
06D2  0023     MOVLB 0x3
06D3  0191     CLRF PMADR
06D4  0791     ADDWF PMADR, F
69:                    PMCON2=0x55;
06D5  3055     MOVLW 0x55
06D6  0096     MOVWF PMCON2
70:                    PMCON2=0xAA;
06D7  30AA     MOVLW 0xAA
06D8  0096     MOVWF PMCON2
71:                    PMCON1bits.WR=1;
06D9  1495     BSF PMCON1, 0x1
72:                    while(PMCON1bits.WR);
06DA  1895     BTFSC PMCON1, 0x1
06DB  2EDA     GOTO 0x6DA
73:                    NOP();
06DC  0000     NOP
74:                    NOP();
06DD  0000     NOP
75:            
76:                    //Aggiorna il contenuto della nuova riga.
77:                    for(;latchAddr<sizeof(bufTmpRow)/sizeof(unsigned short);latchAddr++)
06DE  3020     MOVLW 0x20
06DF  0020     MOVLB 0x0
06E0  0263     SUBWF latchAddr, W
06E1  1803     BTFSC STATUS, 0x0
06E2  2F06     GOTO 0x706
06FE  3001     MOVLW 0x1
06FF  00F5     MOVWF product
0700  0875     MOVF product, W
0701  07E3     ADDWF latchAddr, F
0702  3020     MOVLW 0x20
0703  0263     SUBWF latchAddr, W
0704  1C03     BTFSS STATUS, 0x0
0705  2EE3     GOTO 0x6E3
78:                    {
79:                        CLRWDT();
06E3  0064     CLRWDT
80:                        //Controlla se interrompere il ciclo.
81:                        if(i>=len)
06E4  0874     MOVF ff2, W
06E5  0020     MOVLB 0x0
06E6  0262     SUBWF i, W
06E7  1803     BTFSC STATUS, 0x0
06E8  2F06     GOTO 0x706
82:                            break;
83:                        //Setta il dato.
84:                        bufTmpRow[latchAddr]=(*(source+i));
06E9  0862     MOVF i, W
06EA  0773     ADDWF multiplicand, W
06EB  00F5     MOVWF product
06EC  0875     MOVF product, W
06ED  0086     MOVWF FSR1
06EE  0187     CLRF FSR1H
06EF  0801     MOVF INDF1, W
06F0  00F6     MOVWF bf
06F1  01F7     CLRF rs
06F2  3563     LSLF latchAddr, W
06F3  3E20     ADDLW 0x20
06F4  0086     MOVWF FSR1
06F5  0187     CLRF FSR1H
06F6  0876     MOVF bf, W
06F7  3FC0     MOVWI [0]FSR1
06F8  0877     MOVF rs, W
06F9  3FC1     MOVWI [1]FSR1
85:                        i++;
06FA  3001     MOVLW 0x1
06FB  00F5     MOVWF product
06FC  0875     MOVF product, W
06FD  07E2     ADDWF i, F
86:                    }
87:                    //Azzera l'indirizzo del latch.
88:                    latchAddr=0;
0706  01E3     CLRF latchAddr
89:            
90:                    //Scrive la riga sulla PGM.
91:                    for(j=0;j<sizeof(bufTmpRow)/sizeof(unsigned short);j++)
0707  01E4     CLRF j
0708  3020     MOVLW 0x20
0709  0264     SUBWF j, W
070A  1803     BTFSC STATUS, 0x0
070B  2F3E     GOTO 0x73E
0735  3001     MOVLW 0x1
0736  00F5     MOVWF product
0737  0875     MOVF product, W
0738  0020     MOVLB 0x0
0739  07E4     ADDWF j, F
073A  3020     MOVLW 0x20
073B  0264     SUBWF j, W
073C  1C03     BTFSS STATUS, 0x0
073D  2F0C     GOTO 0x70C
92:                    {
93:                        //Setta l'indirizzo.
94:                        PMADR=(rowAddr+j);
070C  0864     MOVF j, W
070D  0760     ADDWF rowAddr, W
070E  00F5     MOVWF product
070F  0861     MOVF 0x61, W
0710  1803     BTFSC STATUS, 0x0
0711  0A61     INCF 0x61, W
0712  00F6     MOVWF bf
0713  0875     MOVF product, W
0714  0023     MOVLB 0x3
0715  0091     MOVWF PMADR
0716  0876     MOVF 0x1F6, W
0717  0092     MOVWF PMADRH
95:                        PMDAT=bufTmpRow[j];
0718  0020     MOVLB 0x0
0719  3564     LSLF j, W
071A  3E20     ADDLW 0x20
071B  0086     MOVWF FSR1
071C  0187     CLRF FSR1H
071D  3F40     MOVIW [0]FSR1
071E  0023     MOVLB 0x3
071F  0093     MOVWF PMDAT
0720  3F41     MOVIW [1]FSR1
0721  0094     MOVWF PMDATH
96:                        //Controlla se è arrivato a fine latch.
97:                        if(j==(sizeof(bufTmpRow)/sizeof(unsigned short)-1))
0722  0020     MOVLB 0x0
0723  0864     MOVF j, W
0724  3A1F     XORLW 0x1F
0725  1D03     BTFSS STATUS, 0x2
0726  2F2A     GOTO 0x72A
98:                            PMCON1bits.LWLO=0;
0727  0023     MOVLB 0x3
0728  1295     BCF PMCON1, 0x5
0729  2F2C     GOTO 0x72C
99:                        else
100:                           PMCON1bits.LWLO=1;
072A  0023     MOVLB 0x3
072B  1695     BSF PMCON1, 0x5
101:                       PMCON2=0x55;
072C  3055     MOVLW 0x55
072D  0096     MOVWF PMCON2
102:                       PMCON2=0xAA;
072E  30AA     MOVLW 0xAA
072F  0096     MOVWF PMCON2
103:                       PMCON1bits.WR=1;
0730  1495     BSF PMCON1, 0x1
104:                       while(PMCON1bits.WR);
0731  1895     BTFSC PMCON1, 0x1
0732  2F31     GOTO 0x731
105:                       NOP();
0733  0000     NOP
106:                       NOP();
0734  0000     NOP
107:                   }
108:                   //Incrementa l'indirizzo della riga.
109:                   rowAddr+=0x0020;
073E  3020     MOVLW 0x20
073F  07E0     ADDWF 0x1E0, F
0740  3000     MOVLW 0x0
0741  3DE1     ADDWFC 0x1E1, F
110:               }
111:           
112:               INTCONbits.GIE=1;
0743  178B     BSF 0x18B, 0x7
113:               PMCON1bits.WREN=0;
0744  0023     MOVLB 0x3
0745  1115     BCF PMCON1, 0x2
114:           }	
0746  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/IN.c  ----------------------------------------------
1:             #include <xc.h>
2:             #include "IN.h"
3:             
4:             #define mInitIn() TRISB|=0b00000111; TRISC|=0b00010000; ANSELB&=0b11111000; WPUB=0b00000111
5:             
6:             void INInit(unsigned char sta)
7:             {
16BF  00F2     MOVWF 0x1F2
8:                 switch(sta)
16C0  2ED0     GOTO 0x6D0
16D0  0872     MOVF 0x1F2, W
16D1  3A00     XORLW 0x0
16D2  1903     BTFSC 0x183, 0x2
16D3  2EC1     GOTO 0x6C1
16D4  2ED5     GOTO 0x6D5
9:                 {
10:                    case 0:
11:                        //Inizializzazione hardware.
12:                        mInitIn();
16C1  3007     MOVLW 0x7
16C2  00F1     MOVWF 0x1F1
16C3  0871     MOVF 0x1F1, W
16C4  0021     MOVLB 0x1
16C5  048D     IORWF TRISB, F
16C6  160E     BSF TRISC, 0x4
16C7  30F8     MOVLW 0xF8
16C8  00F1     MOVWF 0xF1
16C9  0871     MOVF 0xF1, W
16CA  0023     MOVLB 0x3
16CB  058D     ANDWF ANSELB, F
16CC  3007     MOVLW 0x7
16CD  0024     MOVLB 0x4
16CE  008D     MOVWF WPUB
13:                        break;
14:            //        case 1:
15:            //            //Inizializzazione variabili.
16:            //            break;
17:            //        case 2:
18:            //            //Inizializzazione applicazione.
19:            //            break;
20:                }
16CF  0008     RETURN
21:            }
16D5  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/DPY.c  ---------------------------------------------
1:             #include <xc.h>
2:             #include "DLY.h"
3:             #include "OUT.h"
4:             #include "DPY.h"
5:             #include "IN.h"
6:             
7:             #define ADDR_PICBATT 0x00
8:             
9:             typedef enum _DPY_RS
10:            {
11:                RS_ISTRUCTION,
12:                RS_DATA
13:            }te_DPY_RS;
14:            
15:            typedef enum _DPY_BF
16:            {
17:                BF_NOTBUSY=0,
18:                BF_BUSY=1
19:            }te_DPY_BF;
20:            
21:            unsigned char picBatt[9]=
22:            {
23:                0b00001110,
24:                0b00011111,
25:                0b00010001,
26:                0b00010001,
27:                0b00010001,
28:                0b00010001,
29:                0b00010001,
30:                0b00011111,
31:            };
32:            
33:            static void DPYInitDisplay(void);
34:            static void DPYWriteNibble(te_DPY_RS,unsigned char);
35:            static void DPYWriteByte(te_DPY_RS,unsigned char);
36:            static te_DPY_BF DPYReadByte(te_DPY_RS,unsigned char *);
37:            static void DPYSendChar(unsigned char);
38:            static void DPYSetCur(unsigned char,unsigned char);
39:            static void DPYDrawChar(unsigned char,char *);
40:            static te_DPY_BF DPYIsBusy(void);
41:            
42:            void DPYInit(unsigned char sta)
43:            {
1649  0020     MOVLB 0x0
164A  00A3     MOVWF f2
44:               switch(sta)
164B  2E4F     GOTO 0x64F
164F  0020     MOVLB 0x0
1650  0823     MOVF f2, W
1651  3A00     XORLW 0x0
1652  1903     BTFSC STATUS, 0x2
1653  2E5B     GOTO 0x65B
1654  3A01     XORLW 0x1
1655  1903     BTFSC STATUS, 0x2
1656  2E5B     GOTO 0x65B
1657  3A03     XORLW 0x3
1658  1903     BTFSC STATUS, 0x2
1659  2E4C     GOTO 0x64C
165A  2E5B     GOTO 0x65B
45:                {
46:                    case 0:
47:                        //Inizializzazione hardware.
48:                        break;
49:                    case 1:
50:                        //Inizializzazione variabili.
51:                        break;
52:                    case 2:
53:                        //Inizializzazione applicazione.
54:                        DPYInitDisplay();
164C  3189     MOVLP 0x9
164D  2165     CALL 0x165
55:                        break;
56:                }
164E  0008     RETURN
57:            }
165B  0008     RETURN
58:            
59:            static void DPYInitDisplay(void)
60:            {
61:                unsigned char tmp;
62:            
63:                DLYDelay_ms(15);
0965  300F     MOVLW 0xF
64:                OUTSetRSOff();
096C  0022     MOVLB 0x2
096D  130C     BCF LATA, 0x6
65:                OUTSetRWOff();
096E  138C     BCF LATA, 0x7
66:            //    DPYWriteNibble(RS_ISTRUCTION,0b00000011);
67:            //
68:            //    DLYDelay_ms(5);
69:            //    DPYWriteNibble(RS_ISTRUCTION,0b00000011);
70:            //
71:            //    DLYDelay_us(100);
72:            //    DPYWriteNibble(RS_ISTRUCTION,0b00000011);
73:            
74:            //    //Imosta la modalità a 4 bit.
75:            //    DPYWriteNibble(RS_ISTRUCTION,0b00000010);
76:            //
77:            //    //Imposta la modalità a 4 bit, il numero di linee e la grandezza del font.
78:            //    tmp=0b00100000;
79:            //    #ifdef DPY_N_ONE
80:            //    //Nessuna istruzione.
81:            //    #endif
82:            //    #ifdef DPY_N_TWO
83:            //    tmp|=0b00001000;
84:            //    #endif
85:            //    #ifdef DPY_F_5X8
86:            //    //Nessuna istruzione.
87:            //    #endif
88:            //    #ifdef DPY_F_5X10
89:            //    tmp|=0b00000100;
90:            //    #endif
91:            //    DPYWriteByte(RS_ISTRUCTION,tmp);
92:            
93:                //Accende il display e il cursore.
94:                DPYWriteByte(RS_ISTRUCTION,0b00001110);
096F  300E     MOVLW 0xE
0970  00FB     MOVWF 0x17B
0971  087B     MOVF 0x17B, W
0972  00F5     MOVWF 0x175
0973  3000     MOVLW 0x0
0974  318D     MOVLP 0xD
0975  2553     CALL 0x553
0976  3189     MOVLP 0x9
95:            
96:                //Setta la modalità di incremento.
97:                DPYWriteByte(RS_ISTRUCTION,0b00000110);
0977  3006     MOVLW 0x6
0978  00FB     MOVWF 0x17B
0979  087B     MOVF 0x17B, W
097A  00F5     MOVWF 0x175
097B  3000     MOVLW 0x0
097C  318D     MOVLP 0xD
097D  2553     CALL 0x553
097E  3189     MOVLP 0x9
98:            
99:                //Cancella il display.
100:               DPYWriteByte(RS_ISTRUCTION,0b00000001);
097F  01F5     CLRF 0x175
0980  0AF5     INCF 0x175, F
0981  3000     MOVLW 0x0
0982  318D     MOVLP 0xD
0983  2553     CALL 0x553
0984  3189     MOVLP 0x9
101:           
102:               //Disegna il carattere per la batteria.
103:               DPYDrawChar(ADDR_PICBATT,picBatt);
0985  3053     MOVLW 0x53
0986  00FB     MOVWF 0x17B
0987  087B     MOVF 0x17B, W
0988  00F8     MOVWF 0x178
0989  3000     MOVLW 0x0
098A  318A     MOVLP 0xA
098B  220B     CALL 0x20B
104:           }
098C  0008     RETURN
105:           
106:           static void DPYDrawChar(unsigned char addr,char *p)
107:           {
108:               unsigned char i,tmpAddr;
109:               //Setta l'indirizzo e il dato.
110:               for(i=0;i<9;i++)
0A0B  0020     MOVLB 0x0
0A31  3001     MOVLW 0x1
0A32  00F9     MOVWF c
0A33  0879     MOVF c, W
0A34  0020     MOVLB 0x0
0A35  07A2     ADDWF i, F
0A36  2A0E     GOTO 0x20E
111:               {
112:                   tmpAddr=(((i+addr)&0b00111111)|0b01000000);
0A12  0822     MOVF i, W
0A13  0720     ADDWF __pcstackBANK0, W
0A14  393F     ANDLW 0x3F
0A15  3840     IORLW 0x40
0A16  00F9     MOVWF c
0A17  0879     MOVF c, W
0A18  00A1     MOVWF data
113:                   DPYWriteByte(RS_ISTRUCTION,tmpAddr);
0A19  0821     MOVF data, W
0A1A  00F9     MOVWF c
0A1B  0879     MOVF c, W
0A1C  00F5     MOVWF product
0A1D  3000     MOVLW 0x0
0A1E  318D     MOVLP 0xD
0A1F  2553     CALL 0x553
0A20  318A     MOVLP 0xA
114:                   DPYWriteByte(RS_DATA,(*(p+i)));
0A21  0020     MOVLB 0x0
0A22  0822     MOVF i, W
0A23  0778     ADDWF col, W
0A24  00F9     MOVWF c
0A25  0879     MOVF c, W
0A26  0086     MOVWF FSR1
0A27  3001     MOVLW 0x1
0A28  0087     MOVWF FSR1H
0A29  0801     MOVF INDF1, W
0A2A  00FA     MOVWF row
0A2B  087A     MOVF row, W
0A2C  00F5     MOVWF product
0A2D  3001     MOVLW 0x1
0A2E  318D     MOVLP 0xD
0A2F  2553     CALL 0x553
0A30  318A     MOVLP 0xA
115:               }
116:           }
0A37  307C     MOVLW 0x7C
117:           
118:           static void DPYSetCur(unsigned char row,unsigned char col)
119:           {
120:               unsigned char addr;
121:           
122:               //Ricava l'indirizzo per la scrittura del carattere.
123:               addr=col;
16A9  00FA     MOVWF row
16AA  0878     MOVF col, W
16AB  00F9     MOVWF c
16AC  0879     MOVF c, W
16AD  00FB     MOVWF addr
124:               //Controlla se è la seconda riga.
125:               if(row==1)
16AE  087A     MOVF row, W
16AF  3A01     XORLW 0x1
16B0  1D03     BTFSS STATUS, 0x2
16B1  2EB6     GOTO 0x6B6
126:                   addr+=0x40;
16B2  3040     MOVLW 0x40
16B3  00F9     MOVWF c
16B4  0879     MOVF c, W
16B5  07FB     ADDWF addr, F
127:           
128:               //Setta l'indirizzo.
129:               DPYWriteByte(RS_ISTRUCTION,(addr|0b10000000));
16B6  087B     MOVF addr, W
16B7  3880     IORLW 0x80
16B8  00F9     MOVWF c
16B9  0879     MOVF c, W
16BA  00F5     MOVWF product
16BB  3000     MOVLW 0x0
16BC  318D     MOVLP 0xD
16BD  2553     CALL 0x553
130:           }
16BE  0008     RETURN
131:           
132:           static void DPYSendChar(unsigned char c)
133:           {
134:               //Scrive il carattere.
135:               DPYWriteByte(RS_DATA,c);
15AB  00F9     MOVWF c
15AC  0879     MOVF c, W
15AD  00F8     MOVWF col
15AE  0878     MOVF col, W
15AF  00F5     MOVWF product
15B0  3001     MOVLW 0x1
15B1  318D     MOVLP 0xD
15B2  2553     CALL 0x553
136:           }
15B3  0008     RETURN
137:           
138:           void DPYSendStr(unsigned char row,unsigned char col,char* data,unsigned char len)
139:           {
140:               unsigned char i;
141:           
142:               //Setta la posizione iniziale del cursore.
143:               DPYSetCur(row,col);
0C16  0020     MOVLB 0x0
0C17  00A7     MOVWF row
0C18  0820     MOVF __pcstackBANK0, W
0C19  00A4     MOVWF counter
0C1A  0824     MOVF counter, W
0C1B  00F8     MOVWF col
0C1C  0827     MOVF row, W
0C1D  3196     MOVLP 0x16
0C1E  26A9     CALL 0x6A9
0C1F  318C     MOVLP 0xC
144:           
145:               for(i=0;i<len;i++)
0C20  0020     MOVLB 0x0
0C21  01A6     CLRF i
0C22  0823     MOVF f2, W
0C23  0226     SUBWF i, W
0C24  1803     BTFSC STATUS, 0x0
0C25  0008     RETURN
0C59  3001     MOVLW 0x1
0C5A  0020     MOVLB 0x0
0C5B  00A4     MOVWF counter
0C5C  0824     MOVF counter, W
0C5D  07A6     ADDWF i, F
0C5E  2C22     GOTO 0x422
146:               {
147:                   //Invia i caratteri.
148:                   DPYSendChar((*(data+i)));
0C26  0826     MOVF i, W
0C27  00A4     MOVWF counter
0C28  01A5     CLRF len
0C29  0824     MOVF counter, W
0C2A  0721     ADDWF data, W
0C2B  0086     MOVWF FSR1
0C2C  0825     MOVF len, W
0C2D  3D22     ADDWFC i, W
0C2E  0087     MOVWF FSR1H
0C2F  0801     MOVF INDF1, W
0C30  3195     MOVLP 0x15
0C31  25AB     CALL 0x5AB
0C32  318C     MOVLP 0xC
149:                   while(DPYIsBusy())
0C33  318B     MOVLP 0xB
0C34  2393     CALL 0x393
0C35  318C     MOVLP 0xC
0C36  3800     IORLW 0x0
0C37  1903     BTFSC STATUS, 0x2
0C38  2C3B     GOTO 0x43B
0C3A  2C33     GOTO 0x433
150:                       NOP();
0C39  0000     NOP
151:           
152:                   //Setta il cursore per il prossimo carattere.
153:                   col++;
0C3B  3001     MOVLW 0x1
0C3C  0020     MOVLB 0x0
0C3D  00A4     MOVWF counter
0C3E  0824     MOVF counter, W
0C3F  07A0     ADDWF __pcstackBANK0, F
154:                   if(col==DPY_COL_NUM)
0C40  0820     MOVF __pcstackBANK0, W
0C41  3A10     XORLW 0x10
0C42  1D03     BTFSS STATUS, 0x2
0C43  2C4A     GOTO 0x44A
155:                   {
156:                       col=0;
0C44  01A0     CLRF __pcstackBANK0
157:                       row++;
0C45  3001     MOVLW 0x1
0C46  00A4     MOVWF counter
0C47  0824     MOVF counter, W
0C48  07A7     ADDWF row, F
0C49  2C51     GOTO 0x451
158:                       DPYSetCur(row,col);
159:                   }
160:                   else if(col==32)
0C4A  0020     MOVLB 0x0
0C4B  0820     MOVF __pcstackBANK0, W
0C4C  3A20     XORLW 0x20
0C4D  1D03     BTFSS STATUS, 0x2
0C4E  2C59     GOTO 0x459
161:                   {
162:                       col=0;
0C4F  01A0     CLRF __pcstackBANK0
163:                       row=0;
0C50  01A7     CLRF row
164:                       DPYSetCur(row,col);
0C51  0820     MOVF __pcstackBANK0, W
0C52  00A4     MOVWF counter
0C53  0824     MOVF counter, W
0C54  00F8     MOVWF col
0C55  0827     MOVF row, W
0C56  3196     MOVLP 0x16
0C57  26A9     CALL 0x6A9
0C58  318C     MOVLP 0xC
165:                   }
166:               }
167:           }
0C5F  0020     MOVLB 0x0
168:           
169:           static void DPYWriteNibble(te_DPY_RS rs,unsigned char val)
170:           {
171:               //N.B.: vengono considerati solo i 4 bit meno significativi.
172:           
173:               //Settaggio la linea E.
174:               OUTSetEOff();
175:           
176:               //Settaggio la linea RS.
177:               if(rs==RS_ISTRUCTION)
178:                   OUTSetRSOff();
179:               else if(rs==RS_DATA)
180:                   OUTSetRSOn();
181:           
182:               //Settaggio la linea RW.
183:               OUTSetRWOff();
184:           
185:               //Attesa.
186:               DLYDelay_us(100);
187:           
188:               //Settaggio la linea E.
189:               OUTSetEOn();
190:               //Attesa.
191:               DLYDelay_us(100);
192:               //Settaggio linee dati (MSB).
193:               OUTSetHTCDataNibble(val&0x0F);
194:               //Attesa.
195:               DLYDelay_us(100);
196:               //Settaggio la linea E.
197:               OUTSetEOff();
198:               //Attesa.
199:               DLYDelay_us(100);
200:           }
201:           
202:           static void DPYWriteByte(te_DPY_RS rs,unsigned char val)
203:           {
204:               //Settaggio la linea E.
205:               OUTSetEOff();
0D53  00F7     MOVWF rs
0D54  0022     MOVLB 0x2
0D55  120C     BCF LATA, 0x4
206:           
207:               //Settaggio la linea RS.
208:               if(rs==RS_ISTRUCTION)
0D56  08F7     MOVF 0x177, F
0D57  1D03     BTFSS 0x103, 0x2
0D58  2D5B     GOTO 0x55B
209:                   OUTSetRSOff();
0D59  130C     BCF LATA, 0x6
0D5A  2D5F     GOTO 0x55F
210:               else if(rs==RS_DATA)
0D5B  0877     MOVF 0x177, W
0D5C  3A01     XORLW 0x1
0D5D  1903     BTFSC 0x103, 0x2
211:                   OUTSetRSOn();
0D5E  170C     BSF LATA, 0x6
212:           
213:               //Settaggio la linea RW.
214:               OUTSetRWOff();
0D5F  138C     BCF LATA, 0x7
215:           
216:               //Attesa.
217:               DLYDelay_us(100);
0D60  3064     MOVLW 0x64
0D61  00F1     MOVWF 0x171
0D62  3000     MOVLW 0x0
0D63  00F2     MOVWF 0x172
0D64  3196     MOVLP 0x16
0D65  2627     CALL 0x627
0D66  318D     MOVLP 0xD
218:           
219:               //Settaggio la linea E.
220:               OUTSetEOn();
0D67  0022     MOVLB 0x2
0D68  160C     BSF LATA, 0x4
221:               //Attesa.
222:               DLYDelay_us(100);
0D69  3064     MOVLW 0x64
0D6A  00F1     MOVWF 0x171
0D6B  3000     MOVLW 0x0
0D6C  00F2     MOVWF 0x172
0D6D  3196     MOVLP 0x16
0D6E  2627     CALL 0x627
0D6F  318D     MOVLP 0xD
223:               //Settaggio linee dati (MSB).
224:               OUTSetHTCDataNibble((val>>4)&0b00001111);
0D70  0875     MOVF 0x175, W
0D71  00F6     MOVWF 0x176
0D72  3004     MOVLW 0x4
0D73  36F6     LSRF 0x176, F
0D74  0B89     DECFSZ 0x109, F
0D75  2D73     GOTO 0x573
0D76  0876     MOVF 0x176, W
0D77  390F     ANDLW 0xF
0D78  3197     MOVLP 0x17
0D79  276E     CALL 0x76E
0D7A  318D     MOVLP 0xD
225:               //Attesa.
226:               DLYDelay_us(100);
0D7B  3064     MOVLW 0x64
0D7C  00F1     MOVWF 0x171
0D7D  3000     MOVLW 0x0
0D7E  00F2     MOVWF 0x172
0D7F  3196     MOVLP 0x16
0D80  2627     CALL 0x627
0D81  318D     MOVLP 0xD
227:               //Settaggio la linea E.
228:               OUTSetEOff();
0D82  0022     MOVLB 0x2
0D83  120C     BCF LATA, 0x4
229:               //Attesa.
230:               DLYDelay_us(100);
0D84  3064     MOVLW 0x64
0D85  00F1     MOVWF 0x171
0D86  3000     MOVLW 0x0
0D87  00F2     MOVWF 0x172
0D88  3196     MOVLP 0x16
0D89  2627     CALL 0x627
0D8A  318D     MOVLP 0xD
231:               //Settaggio la linea E.
232:               OUTSetEOn();
0D8B  0022     MOVLB 0x2
0D8C  160C     BSF LATA, 0x4
233:               //Attesa.
234:               DLYDelay_us(100);
0D8D  3064     MOVLW 0x64
0D8E  00F1     MOVWF 0x171
0D8F  3000     MOVLW 0x0
0D90  00F2     MOVWF 0x172
0D91  3196     MOVLP 0x16
0D92  2627     CALL 0x627
0D93  318D     MOVLP 0xD
235:               //Settaggio linee dati (LSB).
236:               OUTSetHTCDataNibble(val&0b00001111);
0D94  0875     MOVF 0x175, W
0D95  390F     ANDLW 0xF
0D96  3197     MOVLP 0x17
0D97  276E     CALL 0x76E
0D98  318D     MOVLP 0xD
237:               //Attesa.
238:               DLYDelay_us(100);
0D99  3064     MOVLW 0x64
0D9A  00F1     MOVWF 0x171
0D9B  3000     MOVLW 0x0
0D9C  00F2     MOVWF 0x172
0D9D  3196     MOVLP 0x16
0D9E  2627     CALL 0x627
0D9F  318D     MOVLP 0xD
239:               //Settaggio la linea E.
240:               OUTSetEOff();
0DA0  0022     MOVLB 0x2
0DA1  120C     BCF LATA, 0x4
241:               //Attesa.
242:               DLYDelay_us(100);
0DA2  3064     MOVLW 0x64
0DA3  00F1     MOVWF 0x171
0DA4  3000     MOVLW 0x0
0DA5  00F2     MOVWF 0x172
0DA6  3196     MOVLP 0x16
0DA7  2627     CALL 0x627
243:           }
0DA8  0008     RETURN
244:           
245:           static te_DPY_BF DPYReadByte(te_DPY_RS rs,unsigned char *val)
246:           {
247:               //Azzeramento valore.
248:               (*(val))=0;
249:           
250:               //Settaggio direzione pin.
251:               tris_DPY|=0b00001111;
252:           
253:               //Settaggio la linea E.
254:               OUTSetEOff();
255:           
256:               //Settaggio la linea RS.
257:               if(rs==RS_ISTRUCTION)
258:                   OUTSetRSOff();
259:               else if(rs==RS_DATA)
260:                   OUTSetRSOn();
261:           
262:               //Settaggio la linea RW.
263:               OUTSetRWOn();
264:           
265:               //Attesa.
266:               DLYDelay_us(100);
267:           
268:               //Settaggio la linea E.
269:               OUTSetEOn();
270:               //Settaggio linee dati (MSB).
271:               if(INGetD7())
272:                   (*(val))|=0b10000000;
273:               if(INGetD6())
274:                   (*(val))|=0b01000000;
275:               if(INGetD5())
276:                   (*(val))|=0b00100000;
277:               if(INGetD4())
278:                   (*(val))|=0b00010000;
279:               //Attesa.
280:               DLYDelay_us(100);
281:               //Settaggio la linea E.
282:               OUTSetEOff();
283:               //Attesa.
284:               DLYDelay_us(100);
285:               //Settaggio la linea E.
286:               OUTSetEOn();
287:               //Settaggio linee dati (LSB).
288:               if(INGetD7())
289:                   (*(val))|=0b00001000;
290:               if(INGetD6())
291:                   (*(val))|=0b00000100;
292:               if(INGetD5())
293:                   (*(val))|=0b00000010;
294:               if(INGetD4())
295:                   (*(val))|=0b00000001;
296:               //Attesa.
297:               DLYDelay_us(100);
298:               //Settaggio la linea E.
299:               OUTSetEOff();
300:               //Attesa.
301:               DLYDelay_us(100);
302:           
303:               //Settaggio busy-flag.
304:               //TODO
305:           
306:               //Settaggio direzione pin.
307:               tris_DPY&=0b11110000;
308:           
309:               if((*(val))&0b10000000)
310:                   return BF_BUSY;
311:               else
312:                   return BF_NOTBUSY;
313:           }
314:           
315:           static te_DPY_BF DPYIsBusy(void)
316:           {
317:               te_DPY_BF bf;
318:               
319:               //Settaggio direzione pin.
320:               tris_DPY|=0b00001111;
0B93  300F     MOVLW 0xF
0B94  00F5     MOVWF 0x175
0B95  0875     MOVF 0x175, W
0B96  0021     MOVLB 0x1
0B97  048C     IORWF TRISA, F
321:           
322:               //Settaggio la linea E.
323:               OUTSetEOff();
0B98  0022     MOVLB 0x2
0B99  120C     BCF LATA, 0x4
324:           
325:               //Settaggio la linea RS.
326:               OUTSetRSOff();
0B9A  130C     BCF LATA, 0x6
327:           
328:               //Settaggio linea RW.
329:               OUTSetRWOn();
0B9B  178C     BSF LATA, 0x7
330:           
331:               //Attesa.
332:               DLYDelay_us(100);
0B9C  3064     MOVLW 0x64
0B9D  00F1     MOVWF 0x171
0B9E  3000     MOVLW 0x0
0B9F  00F2     MOVWF 0x172
0BA0  3196     MOVLP 0x16
0BA1  2627     CALL 0x627
0BA2  318B     MOVLP 0xB
333:           
334:               //Settaggio la linea E.
335:               OUTSetEOn();
0BA3  0022     MOVLB 0x2
0BA4  160C     BSF LATA, 0x4
336:               //Settaggio busy flag.
337:               bf=BF_NOTBUSY;
0BA5  01F6     CLRF 0x176
338:               if(INGetD7())
0BA6  0020     MOVLB 0x0
0BA7  1C0C     BTFSS PORTA, 0x0
0BA8  2BAB     GOTO 0x3AB
339:                   bf=BF_BUSY;
0BA9  01F6     CLRF bf
0BAA  0AF6     INCF bf, F
340:               //Attesa.
341:               DLYDelay_us(100);
0BAB  3064     MOVLW 0x64
0BAC  00F1     MOVWF multiplier
0BAD  3000     MOVLW 0x0
0BAE  00F2     MOVWF val
0BAF  3196     MOVLP 0x16
0BB0  2627     CALL 0x627
0BB1  318B     MOVLP 0xB
342:               //Settaggio la linea E.
343:               OUTSetEOff();
0BB2  0022     MOVLB 0x2
0BB3  120C     BCF LATA, 0x4
344:               //Attesa.
345:               DLYDelay_us(100);
0BB4  3064     MOVLW 0x64
0BB5  00F1     MOVWF 0x171
0BB6  3000     MOVLW 0x0
0BB7  00F2     MOVWF 0x172
0BB8  3196     MOVLP 0x16
0BB9  2627     CALL 0x627
0BBA  318B     MOVLP 0xB
346:               //Settaggio la linea E.
347:               OUTSetEOn();
0BBB  0022     MOVLB 0x2
0BBC  160C     BSF LATA, 0x4
348:               //Attesa.
349:               DLYDelay_us(100);
0BBD  3064     MOVLW 0x64
0BBE  00F1     MOVWF 0x171
0BBF  3000     MOVLW 0x0
0BC0  00F2     MOVWF 0x172
0BC1  3196     MOVLP 0x16
0BC2  2627     CALL 0x627
0BC3  318B     MOVLP 0xB
350:               //Settaggio la linea E.
351:               OUTSetEOff();
0BC4  0022     MOVLB 0x2
0BC5  120C     BCF LATA, 0x4
352:               //Attesa.
353:               DLYDelay_us(100);
0BC6  3064     MOVLW 0x64
0BC7  00F1     MOVWF 0x171
0BC8  3000     MOVLW 0x0
0BC9  00F2     MOVWF 0x172
0BCA  3196     MOVLP 0x16
0BCB  2627     CALL 0x627
354:           
355:               //Settaggio direzione pin.
356:               tris_DPY&=0b11110000;
0BCC  30F0     MOVLW 0xF0
0BCD  00F5     MOVWF 0x175
0BCE  0875     MOVF 0x175, W
0BCF  0021     MOVLB 0x1
0BD0  058C     ANDWF TRISA, F
357:           
358:               return bf;
0BD1  0876     MOVF 0xF6, W
0BD2  0008     RETURN
359:           }
0BD3  0020     MOVLB 0x0
0BD4  0828     MOVF src, W
360:           
361:           ////----------------------------------------------------------------------------------------------------
362:           ////Function LcdInit
363:           ////Descrizione           : inizializza il display
364:           ////Parametri passati     : nessuno
365:           ////Parametri restituiti  : nessuno
366:           //
367:           ////----------------------------------------------------------------------------------------------------
368:           ////Caratteristiche del display LCD
369:           //#define ROWS 2      //numero di righe
370:           //#define COLS 16     //numero di colonne
371:           ////----------------------------------------------------------------------------------------------------
372:           //
373:           ////----------------------------------------------------------------------------------------------------
374:           ////Cablaggio pin LCD
375:           //#define	RS    pin_RS
376:           //#define	RW    pin_RW
377:           //#define	EN    pin_E
378:           //
379:           //#define LCD_D4    pin_D4
380:           //#define LCD_D5    pin_D5
381:           //#define LCD_D6    pin_D6
382:           //#define LCD_D7    pin_D7
383:           ////#define LCDPORT   PORTA      // Porta di I/O display LCD
384:           ////----------------------------------------------------------------------------------------------------
385:           //
386:           ////----------------------------------------------------------------------------------------------------
387:           //#define Read            1
388:           //#define Write           0
389:           //#define LCDOUTPUT   0b00000000 	 	  // Direzione port con bus dati da uC  a LCD
390:           //#define LCDINPUT    0x00011111 		  // Direzione port con bus dati da LCD a uC
391:           ////----------------------------------------------------------------------------------------------------
392:           //
393:           //void LcdInit(void);
394:           //void LcdStrobe(void);
395:           //void putch (unsigned char);
396:           //
397:           //void LcdInit(void)
398:           //{
399:           //  TRISA = LCDOUTPUT;                               // Inizializzazione direzione PORTA
400:           //  DLYDelay_us(10000);                                    // Attendo Power On LCD Controller
401:           //  RS=0; RW=0; LCD_D7=0; LCD_D6=0; LCD_D5=1; LCD_D4=0;    // Function set 4 bit
402:           //  DLYDelay_us(15000);
403:           //  LcdStrobe();        // Clock su EN
404:           //  DLYDelay_us(10000);
405:           //  LcdStrobe();        // Clock per Display
406:           //  DLYDelay_us(10000);
407:           //  LcdStrobe();        // Clock per Display
408:           //  DLYDelay_us(10000);
409:           //  putch(0b00100000);                             // 4 bit
410:           //  putch(0b00101000);                             // 4 bit, 2 lines, 5*7 dots
411:           //  putch(0b00001000);                             // Display OFF
412:           //  putch(0b00001100);                             // Display ON
413:           //  putch(0b00000001);                             // Display clear
414:           //  putch(0b00000110);                             // Auto increment ON + no shift
415:           //  DLYDelay_us(10000);
416:           // }
417:           ////----------------------------------------------------------------------------------------------------
418:           //
419:           ////----------------------------------------------------------------------------------------------------
420:           ////Function LcdStrobe
421:           ////Descrizione           : da uno strobe (1-->0) su enable (EN)
422:           ////Parametri passati     : nessuno
423:           ////Parametri restituiti  : nessuno
424:           //
425:           //void LcdStrobe(void)
426:           //{
427:           // EN = 1;
428:           // DLYDelay_us(10);
429:           // EN = 0;
430:           //}
431:           ////----------------------------------------------------------------------------------------------------
432:           //
433:           ////----------------------------------------------------------------------------------------------------
434:           ////Function LcdBusy
435:           ////Descrizione          : interroga il display per vedere se è libero
436:           ////Parametri passati    : nessuno
437:           ////Parametri restituiti : unsigned char (0 --> Lcd libero, ~0 --> Lcd occupato)
438:           //
439:           //unsigned char LcdBusy (void)
440:           //{
441:           // TRISA = LCDINPUT;               //Lcd --> uC
442:           // RW = Read;                      //In lettura
443:           // return(LCD_D7);                 //LcdBusy = 1 --> LCD occupato
444:           //                                 //LcdBusy = 0 --> LCD libero
445:           //}
446:           ////----------------------------------------------------------------------------------------------------
447:           //
448:           ////----------------------------------------------------------------------------------------------------
449:           ////Function LcdGotoXY
450:           ////Descrizione           : posizione il cursore sul display
451:           ////Parametri passati     : numero di riga (unsigned char) e numero di colonna (unsigned char)
452:           ////Parametri restituiti  : nessuno
453:           //
454:           //void LcdGotoXY (unsigned char Riga, unsigned char Colonna)
455:           //{
456:           //  static unsigned char Data;
457:           //  static bit Temp;
458:           //  Temp = RS;                                        // BackUp del bit CONTROLLO/DATO
459:           //  TRISA = LCDOUTPUT;                                // Inizializzazione direzione PORTA
460:           //  RS = 0;                                           // Parole di controllo ...
461:           //  if (Riga    <  1)    Riga    =  1;                // Saturazione Riga min
462:           //  if (Riga    >  ROWS) Riga    =  2;                // Saturazione Riga max
463:           //  if (Colonna <  1)    Colonna =  1;                // Saturazione Colonna min
464:           //  if (Colonna > COLS)  Colonna = 16;                // Saturazione Colonna max
465:           //
466:           //  switch (Riga)
467:           //  {
468:           //   case 1:
469:           //   Data = 0x80;
470:           //   break;
471:           //
472:           //   case 2:
473:           //   Data = 0xC0;
474:           //   break;
475:           //
476:           //   case 3:
477:           //   Data = 0x90;
478:           //   break;
479:           //
480:           //   case 4:
481:           //   Data = 0xD0;
482:           //   break;
483:           //  }
484:           //
485:           //  Data  += Colonna - 1;
486:           //  putch(Data);                                   // Esegui comando
487:           //  RS = Temp;
488:           //}
489:           ////----------------------------------------------------------------------------------------------------
490:           //
491:           ////----------------------------------------------------------------------------------------------------
492:           ////Function LcdDelLine
493:           ////Descrizione           : cancella una linea sul display
494:           ////Parametri passati     : numero di riga (unsigned char)
495:           ////Parametri restituiti  : nessuno
496:           //
497:           //void LcdDelLine (unsigned char Riga)
498:           //{
499:           //  unsigned char i;
500:           //  for (i=1; i<COLS+1; i++)
501:           //  {
502:           //   LcdGotoXY (Riga,i);
503:           //   RS = 1;
504:           //   putch(' ');
505:           //  }
506:           //}
507:           ////----------------------------------------------------------------------------------------------------
508:           //
509:           ////----------------------------------------------------------------------------------------------------
510:           ////Function LcdClrScr
511:           ////Descrizione           : pulisce il display
512:           ////Parametri passati     : nessuno
513:           ////Parametri restituiti  : nessuno
514:           //
515:           //void LcdClrScr (void)
516:           //{
517:           // unsigned char m;
518:           // for (m=1; m<ROWS+1; m++)
519:           // {
520:           //  LcdDelLine(m);
521:           // }
522:           //}
523:           ////----------------------------------------------------------------------------------------------------
524:           //
525:           ////----------------------------------------------------------------------------------------------------
526:           ////Function putch
527:           ////Descrizione           : stampa un carattere sul display, overloading di putch <stdio.h>
528:           ////Parametri passati     : carattere da stampare
529:           ////Parametri restituiti  : nessuno
530:           //
531:           // void putch (unsigned char c)
532:           // {
533:           //  static bit Temp;
534:           //
535:           //  Temp = RS;                                 // BackUp del bit CONTROLLO/DATO
536:           //
537:           //  while(!LcdBusy());                               // Attesa da LCD Busy ...
538:           //
539:           //  // Direzione dati: da PIC a LCD
540:           //  TRISA = LCDOUTPUT;                               // Nibble dati in uscita
541:           //
542:           //  // Trasmissione H-Nibble
543:           //  OUTSetHTCDataNibble((c & 0xF0));
544:           //  RS = Temp;
545:           //  RW = Write;                                // Scrittura
546:           //  EN = 1; DLYDelay_us(100); EN = 0; DLYDelay_us(100);    // Clock per Display   Clock su EN
547:           //
548:           //  // Trasmissione L-Nibble
549:           //  OUTSetHTCDataNibble((c & 0x0F)<<4);
550:           //  RS = Temp;
551:           //  RW = Write;                                // Scrittura
552:           //  EN = 1; DLYDelay_us(100); EN = 0; DLYDelay_us(100);    // Clock per Display  Clock su EN
553:           //}
554:           ////----------------------------------------------------------------------------------------------------
---  D:/Progetti/Termometro wireless/Firmware/Base.X/DLY.c  ---------------------------------------------
1:             
2:             #include <xc.h>
3:             #include "Base.h"
4:             #include "DLY.h"
5:             
6:             void DLYDelay_us(unsigned short val)
7:             {
8:                 unsigned short i;
9:             
10:                for(i=0;i<val;i++)
1627  01F3     CLRF multiplicand
1628  01F4     CLRF ff2
1629  0872     MOVF val, W
162A  0274     SUBWF ff2, W
162B  1D03     BTFSS STATUS, 0x2
162C  2E2F     GOTO 0x62F
162D  0871     MOVF multiplier, W
162E  0273     SUBWF multiplicand, W
162F  1803     BTFSC STATUS, 0x0
1630  0008     RETURN
1633  3001     MOVLW 0x1
1634  07F3     ADDWF multiplicand, F
1635  3000     MOVLW 0x0
1636  3DF4     ADDWFC ff2, F
1637  2E29     GOTO 0x629
11:                {
12:                    CLRWDT();
1631  0064     CLRWDT
13:                    __delay_us(1);
1632  2E33     GOTO 0x633
14:                }
15:            }
1638  340E     RETLW 0xE
16:            
17:            void DLYDelay_ms(unsigned short val)
18:            {
19:                unsigned short i;
20:            
21:                for(i=0;i<val;i++)
16ED  01F5     CLRF product
16EE  01F6     CLRF bf
16EF  0872     MOVF val, W
16F0  0276     SUBWF bf, W
16F1  1D03     BTFSS STATUS, 0x2
16F2  2EF5     GOTO 0x6F5
16F3  0871     MOVF multiplier, W
16F4  0275     SUBWF product, W
16F5  1803     BTFSC STATUS, 0x0
16F6  0008     RETURN
1701  3001     MOVLW 0x1
1702  07F5     ADDWF product, F
1703  3000     MOVLW 0x0
1704  3DF6     ADDWFC bf, F
1705  2EEF     GOTO 0x6EF
22:                {
23:                    CLRWDT();
16F7  0064     CLRWDT
24:                    __delay_ms(1);
16F8  3003     MOVLW 0x3
16F9  00F4     MOVWF ff2
16FA  3097     MOVLW 0x97
16FB  00F3     MOVWF multiplicand
16FC  0BF3     DECFSZ multiplicand, F
16FD  2EFC     GOTO 0x6FC
16FE  0BF4     DECFSZ ff2, F
16FF  2EFC     GOTO 0x6FC
1700  2F01     GOTO 0x701
25:                }
26:            }
1706  3080     MOVLW 0x80
27:            
---  D:/Progetti/Termometro wireless/Firmware/Base.X/DIN.c  ---------------------------------------------
1:             #include <xc.h>
2:             #include "IN.h"
3:             #include "DIN.h"
4:             
5:             #define MAX_TMRDBNCSEL      5		//Debounce 50ms con base tempi 10ms.
6:             
7:             #define MAX_TMRLONGSEL      200     //Pressione prolungata 5s con base tempi 10ms.
8:             
9:             typedef union _FLG_DIN
10:            {
11:                unsigned char val;
12:                struct
13:                {
14:                    unsigned int tmrDbncSel:1;
15:                    unsigned int tmrLongSel:1;
16:                };
17:            }tu_FLG_DIN;
18:            
19:            static tu_FLG_DIN u_flg_din;
20:            static tu_STA_DIN u_in_sta_currTask,u_in_sta_tmpTask;
21:            static unsigned char tmrDbncSel;
22:            static unsigned short tmrLongSel;
23:            
24:            void DINInit(unsigned char sta)
25:            {
1607  00F1     MOVWF multiplier
26:               switch(sta)
1608  2E11     GOTO 0x611
1611  0871     MOVF multiplier, W
1612  3A01     XORLW 0x1
1613  1903     BTFSC STATUS, 0x2
1614  2E09     GOTO 0x609
1615  2E16     GOTO 0x616
27:                {
28:            //        case 0:
29:            //            //Inizializzazione hardware.
30:            //            break;
31:                    case 1:
32:                        //Inizializzazione variabili.
33:                        u_flg_din.val=0;
1609  0021     MOVLB 0x1
160A  01AD     CLRF u_flg_din
34:                        u_in_sta_currTask.val=0;
160B  01B1     CLRF u_in_sta_currTask
35:                        u_in_sta_tmpTask.val=0;
160C  01B2     CLRF u_in_sta_tmpTask
36:                        u_in_ev_up.val=0;
160D  01B0     CLRF u_in_ev_up
37:                        u_in_ev_down.val=0;
160E  01AE     CLRF u_in_ev_down
38:                        u_in_ev_long.val=0;
160F  01AF     CLRF u_in_ev_long
39:                        break;
40:            //        case 2:
41:            //            //Inizializzazione applicazione.
42:            //            break;
43:                }
1610  0008     RETURN
44:            }
1616  0008     RETURN
45:            
46:            void DINTick(void)
47:            {
48:            
49:                //Timer per debounce tasti.
50:                if(u_flg_din.tmrDbncSel)
08AC  0021     MOVLB 0x1
08AD  1C2D     BTFSS u_flg_din, 0x0
08AE  28BE     GOTO 0xBE
51:                {
52:                    tmrDbncSel++;
08AF  3001     MOVLW 0x1
08B0  00F1     MOVWF 0xF1
08B1  0871     MOVF 0xF1, W
08B2  07AA     ADDWF tmrDbncSel, F
53:                    if(tmrDbncSel>MAX_TMRDBNCSEL)
08B3  3006     MOVLW 0x6
08B4  022A     SUBWF tmrDbncSel, W
08B5  1C03     BTFSS 0x83, 0x0
08B6  28BE     GOTO 0xBE
54:                    {
55:                        u_flg_din.tmrDbncSel=0;
08B7  102D     BCF u_flg_din, 0x0
56:                        tmrDbncSel=0;
08B8  01AA     CLRF tmrDbncSel
57:                        //Setta il flag.
58:                        if(u_in_sta_currTask.sel)
08B9  1C31     BTFSS u_in_sta_currTask, 0x0
08BA  28BD     GOTO 0xBD
59:                            u_in_ev_down.sel=1;
08BB  142E     BSF u_in_ev_down, 0x0
08BC  28BE     GOTO 0xBE
60:                        else
61:                            u_in_ev_up.sel=1;
08BD  1430     BSF u_in_ev_up, 0x0
62:                    }
63:                }
64:               
65:                //Timer per pressione prolungata tasti.
66:                if(u_flg_din.tmrLongSel)
08BE  1CAD     BTFSS u_flg_din, 0x1
08BF  0008     RETURN
67:                {
68:                    tmrLongSel++;
08C0  3001     MOVLW 0x1
08C1  07A2     ADDWF tmrLongSel, F
08C2  3000     MOVLW 0x0
08C3  3DA3     ADDWFC 0xA3, F
69:                    if(tmrLongSel>MAX_TMRLONGSEL)
08C4  3000     MOVLW 0x0
08C5  0223     SUBWF 0xA3, W
08C6  30C9     MOVLW 0xC9
08C7  1903     BTFSC 0x83, 0x2
08C8  0222     SUBWF tmrLongSel, W
08C9  1C03     BTFSS 0x83, 0x0
08CA  0008     RETURN
70:                    {
71:                        //u_flg_din.tmrLongSel=0;    //Non azzera il flag perchè deve rilevare in modo continuo la pressione prolungata.
72:                        tmrLongSel=0;
08CB  01A2     CLRF tmrLongSel
08CC  01A3     CLRF 0xA3
73:                        //Setta il flag.
74:                        u_in_ev_long.sel=1;
08CD  142F     BSF u_in_ev_long, 0x0
75:                    }
08CE  0008     RETURN
76:                }
77:            }
08CF  0020     MOVLB 0x0
78:            
79:            void DINTask(void)
80:            {
81:                u_in_sta_tmpTask.val=0;
086A  0021     MOVLB 0x1
086B  01B2     CLRF u_in_sta_tmpTask
82:                if(INGetSEL())
086C  0020     MOVLB 0x0
086D  190D     BTFSC PORTB, 0x2
086E  2871     GOTO 0x71
83:                    u_in_sta_tmpTask.sel=1;
086F  0021     MOVLB 0x1
0870  1432     BSF u_in_sta_tmpTask, 0x0
84:            
85:                //Controlla se ci sono stati variazioni di stato.
86:                if(u_in_sta_currTask.sel!=u_in_sta_tmpTask.sel)
0871  0021     MOVLB 0x1
0872  0832     MOVF u_in_sta_tmpTask, W
0873  3901     ANDLW 0x1
0874  00F1     MOVWF 0xF1
0875  0831     MOVF u_in_sta_currTask, W
0876  3901     ANDLW 0x1
0877  0671     XORWF 0xF1, W
0878  1903     BTFSC 0x83, 0x2
0879  2881     GOTO 0x81
87:                {
88:                    u_in_sta_currTask.sel=u_in_sta_tmpTask.sel;
087A  1031     BCF u_in_sta_currTask, 0x0
087B  1C32     BTFSS u_in_sta_tmpTask, 0x0
087C  287E     GOTO 0x7E
087D  1431     BSF u_in_sta_currTask, 0x0
89:                    tmrDbncSel=0;
087E  0021     MOVLB 0x1
087F  01AA     CLRF tmrDbncSel
90:                    u_flg_din.tmrDbncSel=1;
0880  142D     BSF u_flg_din, 0x0
91:                }
92:            
93:                //Controllo pressioni prolungate.
94:                if(u_in_sta_currTask.sel)
0881  1C31     BTFSS u_in_sta_currTask, 0x0
0882  2885     GOTO 0x85
95:                    u_flg_din.tmrLongSel=1;
0883  14AD     BSF u_flg_din, 0x1
0884  0008     RETURN
96:                else
97:                {
98:                    tmrLongSel=0;           //L'azzeramento deve essere eseguito sul rilascio perchè deve rilevare in modo continuo la pressione prolungata.
0885  01A2     CLRF tmrLongSel
0886  01A3     CLRF 0xA3
99:                    u_flg_din.tmrLongSel=0;
0887  10AD     BCF u_flg_din, 0x1
0888  0008     RETURN
100:               }
101:           }
0889  00F2     MOVWF 0xF2
088A  28A3     GOTO 0xA3
088B  3006     MOVLW 0x6
088C  0021     MOVLB 0x1
088D  0095     MOVWF OPTION_REG
088E  3071     MOVLW 0x71
088F  0099     MOVWF OSCCON
0890  3009     MOVLW 0x9
0891  0097     MOVWF WDTCON
0892  3063     MOVLW 0x63
0893  0020     MOVLB 0x0
0894  0095     MOVWF TMR0
0895  168B     BSF INTCON, 0x5
0896  30FB     MOVLW 0xFB
0897  00F1     MOVWF multiplier
0898  0871     MOVF multiplier, W
0899  058B     ANDWF INTCON, F
089A  0191     CLRF PIR1
089B  0192     CLRF PIR2
089C  0021     MOVLB 0x1
089D  0191     CLRF PIE1
089E  0192     CLRF PIE2
089F  0008     RETURN
08A0  0021     MOVLB 0x1
08A1  01AC     CLRF u_SYS_STA
08A2  0008     RETURN
08A3  0872     MOVF 0xF2, W
08A4  3A00     XORLW 0x0
08A5  1903     BTFSC 0x83, 0x2
08A6  288B     GOTO 0x8B
08A7  3A01     XORLW 0x1
08A8  1903     BTFSC 0x83, 0x2
08A9  28A0     GOTO 0xA0
08AA  28AB     GOTO 0xAB
08AB  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/CC1.c  ---------------------------------------------
1:             #include <xc.h>
2:             #include "SPI.h"
3:             #include "OUT.h"
4:             #include "smartrf_CC1101.h"
5:             #include "CC1.h"
6:             
7:             #define SIZE_INIT_VAL 0x2E
8:             #define SIZE_PATABLE 8
9:             
10:            //Definizioni macro.
11:            #define mCc1Init() IOCBP=0b00000000; IOCBN=0b00000000
12:            
13:            unsigned char cc1InitVal[]=
0800  3400     RETLW 0x0
14:            {
15:            	SMARTRF_SETTING_IOCFG2,
16:            	SMARTRF_SETTING_IOCFG1,
17:            	SMARTRF_SETTING_IOCFG0,
18:            	SMARTRF_SETTING_FIFOTHR,
19:            	SMARTRF_SETTING_SYNC1,
20:            	SMARTRF_SETTING_SYNC0,
21:            	SMARTRF_SETTING_PKTLEN,
22:            	SMARTRF_SETTING_PKTCTRL1,
23:            	SMARTRF_SETTING_PKTCTRL0,
24:            	SMARTRF_SETTING_ADDR,
25:            	SMARTRF_SETTING_CHANNR,
26:            	SMARTRF_SETTING_FSCTRL1,
27:            	SMARTRF_SETTING_FSCTRL0,
28:            	SMARTRF_SETTING_FREQ2,
29:            	SMARTRF_SETTING_FREQ1,
30:            	SMARTRF_SETTING_FREQ0,
31:            	SMARTRF_SETTING_MDMCFG4,
32:            	SMARTRF_SETTING_MDMCFG3,
33:            	SMARTRF_SETTING_MDMCFG2,
34:            	SMARTRF_SETTING_MDMCFG1,
35:            	SMARTRF_SETTING_MDMCFG0,
36:            	SMARTRF_SETTING_DEVIATN,
37:            	SMARTRF_SETTING_MCSM2,
38:            	SMARTRF_SETTING_MCSM1,
39:            	SMARTRF_SETTING_MCSM0,
40:            	SMARTRF_SETTING_FOCCFG,
41:            	SMARTRF_SETTING_BSCFG,
42:            	SMARTRF_SETTING_AGCCTRL2,
43:            	SMARTRF_SETTING_AGCCTRL1,
44:            	SMARTRF_SETTING_AGCCTRL0,
45:            	SMARTRF_SETTING_WOREVT1,
46:            	SMARTRF_SETTING_WOREVT0,
47:            	SMARTRF_SETTING_WORCTRL,
48:            	SMARTRF_SETTING_FREND1,
49:            	SMARTRF_SETTING_FREND0,
50:            	SMARTRF_SETTING_FSCAL3,
51:            	SMARTRF_SETTING_FSCAL2,
52:            	SMARTRF_SETTING_FSCAL1,
53:            	SMARTRF_SETTING_FSCAL0,
54:            	SMARTRF_SETTING_RCCTRL1,
55:            	SMARTRF_SETTING_RCCTRL0,
56:            	SMARTRF_SETTING_FSTEST,
57:            	SMARTRF_SETTING_PTEST,
58:            	SMARTRF_SETTING_AGCTEST,
59:            	SMARTRF_SETTING_TEST2,
60:            	SMARTRF_SETTING_TEST1,
61:            	SMARTRF_SETTING_TEST0
62:            };
63:            
64:            unsigned char cc1PaTable[]=
65:            {
66:            	0x03,
67:            	0x0F,
68:            	0x1E,
69:            	0x27,
70:            	0x50,
71:            	0x81,
72:            	0xCB,
73:            	0xC2
74:            };	
75:            
76:            void CC1Init(unsigned char state)
77:            {
0AF0  0020     MOVLB 0x0
0AF1  00A2     MOVWF i
78:            	
79:            	switch(state)
0AF2  2B15     GOTO 0x315
0B15  0020     MOVLB 0x0
0B16  0822     MOVF i, W
0B17  3A00     XORLW 0x0
0B18  1903     BTFSC STATUS, 0x2
0B19  2AF3     GOTO 0x2F3
0B1A  3A01     XORLW 0x1
0B1B  1903     BTFSC STATUS, 0x2
0B1C  2B21     GOTO 0x321
0B1D  3A03     XORLW 0x3
0B1E  1903     BTFSC STATUS, 0x2
0B1F  2AF7     GOTO 0x2F7
0B20  2B21     GOTO 0x321
80:            	{
81:            		case 0:
82:            			//Inizializzazione hardware.
83:            			mCc1Init();
0AF3  0027     MOVLB 0x7
0AF4  0194     CLRF IOCBP
0AF5  0195     CLRF IOCBN
84:            			break;
85:            		case 1:
86:            			//Inizializzazione variabili.
87:            			break;
0AF6  0008     RETURN
88:            		case 2:
89:            			//Inizializzazione applicazione.
90:            			CC1Strobe(SRES);
0AF7  3030     MOVLW 0x30
0AF8  3196     MOVLP 0x16
0AF9  2695     CALL 0x695
0AFA  318A     MOVLP 0xA
91:            			CC1Write(0x00,cc1InitVal,SIZE_INIT_VAL);
0AFB  30A0     MOVLW 0xA0
0AFC  0020     MOVLB 0x0
0AFD  00A0     MOVWF __pcstackBANK0
0AFE  0820     MOVF __pcstackBANK0, W
0AFF  00F7     MOVWF rs
0B00  302E     MOVLW 0x2E
0B01  00A1     MOVWF data
0B02  0821     MOVF data, W
0B03  00F8     MOVWF col
0B04  3000     MOVLW 0x0
0B05  3188     MOVLP 0x8
0B06  204B     CALL 0x4B
0B07  318A     MOVLP 0xA
92:            			CC1Write(0x3E,cc1PaTable,SIZE_PATABLE);
0B08  305C     MOVLW 0x5C
0B09  0020     MOVLB 0x0
0B0A  00A0     MOVWF __pcstackBANK0
0B0B  0820     MOVF __pcstackBANK0, W
0B0C  00F7     MOVWF rs
0B0D  3008     MOVLW 0x8
0B0E  00A1     MOVWF data
0B0F  0821     MOVF data, W
0B10  00F8     MOVWF col
0B11  303E     MOVLW 0x3E
0B12  3188     MOVLP 0x8
0B13  204B     CALL 0x4B
93:            			break;
94:            	}
0B14  0008     RETURN
95:            }
0B21  0008     RETURN
96:            
97:            void CC1Strobe(te_CC1_STB e_stb)
98:            {
99:            	unsigned char cc1Stb,i;
100:           
101:           	//Imposta il CS.
102:                   OUTSetSSOff();
1695  00F8     MOVWF col
1696  0022     MOVLB 0x2
1697  128C     BCF LATA, 0x5
103:           
104:           	//Scrive il command strobe.
105:           	cc1Stb=((e_stb&0b00111111)|0b10000000);
1698  0878     MOVF 0x178, W
1699  393F     ANDLW 0x3F
169A  3880     IORLW 0x80
169B  00F7     MOVWF 0x177
169C  0877     MOVF 0x177, W
169D  00F9     MOVWF 0x179
106:           	SPIWrite((&(cc1Stb)),1);
169E  3079     MOVLW 0x79
169F  00F1     MOVWF 0x171
16A0  3000     MOVLW 0x0
16A1  00F2     MOVWF 0x172
16A2  01F3     CLRF 0x173
16A3  0AF3     INCF 0x173, F
16A4  3197     MOVLP 0x17
16A5  278A     CALL 0x78A
107:           
108:           	//Imposta il CS.
109:                   OUTSetSSOn();
16A6  0022     MOVLB 0x2
16A7  168C     BSF LATA, 0x5
110:           }
16A8  0008     RETURN
111:           
112:           void CC1Read(unsigned char addr,unsigned char *dst,unsigned char len)
113:           {
114:           	unsigned char cc1Addr;
115:           	
116:           	//Imposta il CS.
117:                   OUTSetSSOff();
08CF  0020     MOVLB 0x0
08D0  00A3     MOVWF f2
08D1  0022     MOVLB 0x2
08D2  128C     BCF LATA, 0x5
118:           
119:           	//Scrive l'indirizzo da cui iniziare a leggere i dati.
120:           	cc1Addr=((addr&0b00111111)|0b11000000);
08D3  0020     MOVLB 0x0
08D4  0823     MOVF f2, W
08D5  393F     ANDLW 0x3F
08D6  38C0     IORLW 0xC0
08D7  00FA     MOVWF row
08D8  087A     MOVF row, W
08D9  00A4     MOVWF counter
121:           	SPIWrite((&(cc1Addr)),1);
08DA  3024     MOVLW 0x24
08DB  00F1     MOVWF multiplier
08DC  3000     MOVLW 0x0
08DD  00F2     MOVWF val
08DE  01F3     CLRF multiplicand
08DF  0AF3     INCF multiplicand, F
08E0  3197     MOVLP 0x17
08E1  278A     CALL 0x78A
08E2  3188     MOVLP 0x8
122:           	
123:           	//Legge i dati.
124:           	SPIRead(dst,len);
08E3  0020     MOVLB 0x0
08E4  0821     MOVF data, W
08E5  01F2     CLRF val
08E6  07F2     ADDWF val, F
08E7  0820     MOVF __pcstackBANK0, W
08E8  01F1     CLRF multiplier
08E9  07F1     ADDWF multiplier, F
08EA  0822     MOVF i, W
08EB  00FA     MOVWF row
08EC  087A     MOVF row, W
08ED  00F3     MOVWF multiplicand
08EE  3189     MOVLP 0x9
08EF  213F     CALL 0x13F
125:           	
126:           	//Imposta il CS.
127:                   OUTSetSSOn();
08F0  0022     MOVLB 0x2
08F1  168C     BSF LATA, 0x5
128:           }
08F2  0008     RETURN
129:           
130:           void CC1Write(unsigned char addr,unsigned char *src,unsigned char len)
131:           {
132:           	unsigned char cc1Addr;
133:           
134:           	//Imposta il CS.
135:                   OUTSetSSOff();
084B  00FA     MOVWF 0x17A
084C  0022     MOVLB 0x2
084D  128C     BCF LATA, 0x5
136:           
137:           	//Scrive l'indirizzo da cui iniziare a scrivere i dati.
138:           	cc1Addr=((addr&0b00111111)|0b01000000);
084E  087A     MOVF 0x17A, W
084F  393F     ANDLW 0x3F
0850  3840     IORLW 0x40
0851  00F9     MOVWF 0x179
0852  0879     MOVF 0x179, W
0853  00FB     MOVWF 0x17B
139:           	SPIWrite((&(cc1Addr)),1);
0854  307B     MOVLW 0x7B
0855  00F1     MOVWF 0x171
0856  3000     MOVLW 0x0
0857  00F2     MOVWF 0x172
0858  01F3     CLRF 0x173
0859  0AF3     INCF 0x173, F
085A  3197     MOVLP 0x17
085B  278A     CALL 0x78A
085C  3188     MOVLP 0x8
140:           	
141:           	//Scrive i dati.
142:           	SPIWrite(src,len);
085D  0877     MOVF 0x177, W
085E  00F1     MOVWF 0x171
085F  3001     MOVLW 0x1
0860  00F2     MOVWF 0x172
0861  0878     MOVF 0x178, W
0862  00F9     MOVWF 0x179
0863  0879     MOVF 0x179, W
0864  00F3     MOVWF 0x173
0865  3197     MOVLP 0x17
0866  278A     CALL 0x78A
143:           	
144:           	//Imposta il CS.
145:                   OUTSetSSOn();
0867  0022     MOVLB 0x2
0868  168C     BSF LATA, 0x5
146:           }
0869  0008     RETURN
---  D:/Progetti/Termometro wireless/Firmware/Base.X/Base.c  --------------------------------------------
1:             
2:             #include <xc.h>
3:             #include "SYS.h"
4:             
5:             #include "IN.h"
6:             #include "DIN.h"
7:             #include "OUT.h"
8:             #include "NVM.h"
9:             #include "SPI.h"
10:            #include "CC1.h"
11:            #include "RTX.h"
12:            #include "PGM.h"
13:            #include "Base.h"
14:            #include "DPY.h"
15:            
16:            #pragma config FCMEN=ON
17:            #pragma config IESO=OFF
18:            #pragma config CLKOUTEN=OFF
19:            #pragma config BOREN=ON
20:            #pragma config CP=ON
21:            #pragma config MCLRE=OFF
22:            #pragma config PWRTE=ON
23:            #pragma config WDTE=ON
24:            #pragma config FOSC=INTOSC
25:            #pragma config LVP=OFF
26:            #pragma config LPBOR=ON
27:            #pragma config BORV=1
28:            #pragma config STVREN=ON
29:            #pragma config VCAPEN=OFF
30:            #pragma config WRT=OFF
31:            
32:            /*NOTE:
33:            
34:            - timer0: tick di sistema con base tempi 10ms.
35:            */
36:            
37:            void interrupt INTIsr(void)
38:            {
0004  3180     MOVLP 0x0
0005  0020     MOVLB 0x0
0006  087F     MOVF 0x7F, W
0007  00F0     MOVWF __pcstackCOMMON
39:                /*Controlla se si è verificato l'interrupt del timer 0.*/
40:                if(INTCONbits.T0IF==1)
0008  1D0B     BTFSS INTCON, 0x2
0009  280D     GOTO 0xD
41:                {
42:                    //Cancella il flag dell'interrupt.
43:                    INTCONbits.T0IF=0;
000A  110B     BCF INTCON, 0x2
44:            
45:                    //Chiama le funzioni interessate.
46:                    SYSInt();
000B  3195     MOVLP 0x15
000C  2584     CALL 0x584
47:                }
48:            }
000D  0870     MOVF __pcstackCOMMON, W
49:            
50:            void main(void)
51:            {
52:                unsigned char i;
53:            
54:                //Inizializzazione.
55:                for(i=0;i<3;i++)
0C5F  0020     MOVLB 0x0
0C60  01EE     CLRF i
0C61  3003     MOVLW 0x3
0C62  026E     SUBWF i, W
0C63  1803     BTFSC STATUS, 0x0
0C64  2CA1     GOTO 0x4A1
0C98  3001     MOVLW 0x1
0C99  0020     MOVLB 0x0
0C9A  00ED     MOVWF 0x6D
0C9B  086D     MOVF 0x6D, W
0C9C  07EE     ADDWF i, F
0C9D  3003     MOVLW 0x3
0C9E  026E     SUBWF i, W
0C9F  1C03     BTFSS STATUS, 0x0
0CA0  2C65     GOTO 0x465
56:                {
57:                    CLRWDT();
0C65  0064     CLRWDT
58:            
59:                    SYSInit(i);
0C66  0020     MOVLB 0x0
0C67  086E     MOVF i, W
0C68  3188     MOVLP 0x8
0C69  2089     CALL 0x89
0C6A  318C     MOVLP 0xC
60:                    INInit(i);
0C6B  0020     MOVLB 0x0
0C6C  086E     MOVF i, W
0C6D  3196     MOVLP 0x16
0C6E  26BF     CALL 0x6BF
0C6F  318C     MOVLP 0xC
61:                    OUTInit(i);
0C70  0020     MOVLB 0x0
0C71  086E     MOVF i, W
0C72  3196     MOVLP 0x16
0C73  26D6     CALL 0x6D6
0C74  318C     MOVLP 0xC
62:                    DINInit(i);
0C75  0020     MOVLB 0x0
0C76  086E     MOVF i, W
0C77  3196     MOVLP 0x16
0C78  2607     CALL 0x607
0C79  318C     MOVLP 0xC
63:                    SPIInit(i);
0C7A  0020     MOVLB 0x0
0C7B  086E     MOVF i, W
0C7C  3197     MOVLP 0x17
0C7D  27C4     CALL 0x7C4
0C7E  318C     MOVLP 0xC
64:                    CC1Init(i);
0C7F  0020     MOVLB 0x0
0C80  086E     MOVF i, W
0C81  318A     MOVLP 0xA
0C82  22F0     CALL 0x2F0
0C83  318C     MOVLP 0xC
65:                    NVMInit(i);
0C84  0020     MOVLB 0x0
0C85  086E     MOVF i, W
0C86  3195     MOVLP 0x15
0C87  25BD     CALL 0x5BD
0C88  318C     MOVLP 0xC
66:                    DPYInit(i);
0C89  0020     MOVLB 0x0
0C8A  086E     MOVF i, W
0C8B  3196     MOVLP 0x16
0C8C  2649     CALL 0x649
0C8D  318C     MOVLP 0xC
67:                    RTXInit(i);
0C8E  0020     MOVLB 0x0
0C8F  086E     MOVF i, W
0C90  3189     MOVLP 0x9
0C91  2119     CALL 0x119
0C92  318C     MOVLP 0xC
68:                    PGMInit(i);
0C93  0020     MOVLB 0x0
0C94  086E     MOVF i, W
0C95  3197     MOVLP 0x17
0C96  271F     CALL 0x71F
0C97  318C     MOVLP 0xC
69:                }
70:            
71:                //Abilita gli interrupt.
72:                INTCONbits.GIE=1;
0CA1  178B     BSF INTCON, 0x7
73:            
74:                //MainLoop.
75:                while(1)
0CAC  2CA2     GOTO 0x4A2
76:                {
77:                    CLRWDT();
0CA2  0064     CLRWDT
78:                    //Task.
79:                    SYSTask();
0CA3  318A     MOVLP 0xA
0CA4  22C0     CALL 0x2C0
0CA5  318C     MOVLP 0xC
80:                    DINTask();
0CA6  3188     MOVLP 0x8
0CA7  206A     CALL 0x6A
0CA8  318C     MOVLP 0xC
81:                    RTXTask();
0CA9  3188     MOVLP 0x8
0CAA  2039     CALL 0x39
0CAB  318C     MOVLP 0xC
82:                }
83:            	
84:            }
0CAD  3000     MOVLW 0x0
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/wmul.c  -----------------------------------------------
1:             unsigned int
2:             __wmul(unsigned int multiplier, unsigned int multiplicand)
3:             {
4:             	unsigned int	product = 0;
17A7  01F5     CLRF product
5:             
6:             	do {
7:             		if(multiplier & 1)
17A9  1C71     BTFSS multiplier, 0x0
8:             			product += multiplicand;
17AB  0873     MOVF multiplicand, W
17AC  07F5     ADDWF product, F
9:             		multiplicand <<= 1;
17AF  3001     MOVLW 0x1
17B0  35F3     LSLF multiplicand, F
17B1  0DF4     RLF ff2, F
10:            		multiplier >>= 1;
17B4  3001     MOVLW 0x1
11:            	} while(multiplier != 0);
17B9  0872     MOVF val, W
17BA  0471     IORWF multiplier, W
12:            	return product;
17BD  0876     MOVF bf, W
17BE  01F2     CLRF val
13:            }
17C4  00F2     MOVWF val
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/lwmod.c  ----------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             __lwmod(unsigned int divisor, unsigned int dividend)
5:             {
6:             	unsigned char	counter;
7:             
8:             	if(divisor != 0) {
0A63  0872     MOVF val, W
0A64  0471     IORWF multiplier, W
0A65  1903     BTFSC STATUS, 0x2
0A66  2A8A     GOTO 0x28A
9:             		counter = 1;
0A67  01F6     CLRF bf
0A68  0AF6     INCF bf, F
10:            		while((divisor & 0x8000) == 0) {
0A69  1BF2     BTFSC val, 0x7
0A6A  2A75     GOTO 0x275
0A74  2A69     GOTO 0x269
11:            			divisor <<= 1;
0A6B  3001     MOVLW 0x1
0A6C  35F1     LSLF multiplier, F
0A6D  0DF2     RLF val, F
0A6E  0B89     DECFSZ WREG, F
0A6F  2A6C     GOTO 0x26C
12:            			counter++;
0A70  3001     MOVLW 0x1
0A71  00F5     MOVWF product
0A72  0875     MOVF product, W
0A73  07F6     ADDWF bf, F
13:            		}
14:            		do {
15:            			if(divisor <= dividend)
0A75  0872     MOVF val, W
0A76  0274     SUBWF ff2, W
0A77  1D03     BTFSS STATUS, 0x2
0A78  2A7B     GOTO 0x27B
0A79  0871     MOVF multiplier, W
0A7A  0273     SUBWF multiplicand, W
0A7B  1C03     BTFSS STATUS, 0x0
0A7C  2A81     GOTO 0x281
16:            				dividend -= divisor;
0A7D  0871     MOVF multiplier, W
0A7E  02F3     SUBWF multiplicand, F
0A7F  0872     MOVF val, W
0A80  3BF4     SUBWFB ff2, F
17:            			divisor >>= 1;
0A81  3001     MOVLW 0x1
0A82  36F2     LSRF val, F
0A83  0CF1     RRF multiplier, F
0A84  0B89     DECFSZ WREG, F
0A85  2A82     GOTO 0x282
18:            		} while(--counter != 0);
0A86  3001     MOVLW 0x1
0A87  02F6     SUBWF bf, F
0A88  1D03     BTFSS STATUS, 0x2
0A89  2A75     GOTO 0x275
19:            	}
20:            	return dividend;
0A8A  0874     MOVF ff2, W
0A8B  01F2     CLRF val
0A8C  07F2     ADDWF val, F
0A8D  0873     MOVF multiplicand, W
0A8E  01F1     CLRF multiplier
0A8F  07F1     ADDWF multiplier, F
0A90  0008     RETURN
21:            }
0A91  3447     RETLW 0x47
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/lwdiv.c  ----------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             __lwdiv(unsigned int divisor, unsigned int dividend)
5:             {
6:             	unsigned int	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0B22  01F6     CLRF bf
0B23  01F7     CLRF rs
10:            	if(divisor != 0) {
0B24  0872     MOVF val, W
0B25  0471     IORWF multiplier, W
0B26  1903     BTFSC STATUS, 0x2
0B27  2B51     GOTO 0x351
11:            		counter = 1;
0B28  01F8     CLRF col
0B29  0AF8     INCF col, F
12:            		while((divisor & 0x8000) == 0) {
0B2A  1BF2     BTFSC val, 0x7
0B2B  2B36     GOTO 0x336
0B35  2B2A     GOTO 0x32A
13:            			divisor <<= 1;
0B2C  3001     MOVLW 0x1
0B2D  35F1     LSLF multiplier, F
0B2E  0DF2     RLF val, F
0B2F  0B89     DECFSZ WREG, F
0B30  2B2D     GOTO 0x32D
14:            			counter++;
0B31  3001     MOVLW 0x1
0B32  00F5     MOVWF product
0B33  0875     MOVF product, W
0B34  07F8     ADDWF col, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0B36  3001     MOVLW 0x1
0B37  35F6     LSLF bf, F
0B38  0DF7     RLF rs, F
0B39  0B89     DECFSZ WREG, F
0B3A  2B37     GOTO 0x337
18:            			if(divisor <= dividend) {
0B3B  0872     MOVF val, W
0B3C  0274     SUBWF ff2, W
0B3D  1D03     BTFSS STATUS, 0x2
0B3E  2B41     GOTO 0x341
0B3F  0871     MOVF multiplier, W
0B40  0273     SUBWF multiplicand, W
0B41  1C03     BTFSS STATUS, 0x0
0B42  2B48     GOTO 0x348
19:            				dividend -= divisor;
0B43  0871     MOVF multiplier, W
0B44  02F3     SUBWF multiplicand, F
0B45  0872     MOVF val, W
0B46  3BF4     SUBWFB ff2, F
20:            				quotient |= 1;
0B47  1476     BSF bf, 0x0
21:            			}
22:            			divisor >>= 1;
0B48  3001     MOVLW 0x1
0B49  36F2     LSRF val, F
0B4A  0CF1     RRF multiplier, F
0B4B  0B89     DECFSZ WREG, F
0B4C  2B49     GOTO 0x349
23:            		} while(--counter != 0);
0B4D  3001     MOVLW 0x1
0B4E  02F8     SUBWF col, F
0B4F  1D03     BTFSS STATUS, 0x2
0B50  2B36     GOTO 0x336
24:            	}
25:            	return quotient;
0B51  0877     MOVF rs, W
0B52  01F2     CLRF val
0B53  07F2     ADDWF val, F
0B54  0876     MOVF bf, W
0B55  01F1     CLRF multiplier
0B56  07F1     ADDWF multiplier, F
0B57  0008     RETURN
26:            }
0B58  1FF3     BTFSS multiplicand, 0x7
0B59  2B6E     GOTO 0x36E
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/lltoft.c  ---------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned long int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __lltoft(unsigned long int c)
17:            {
18:            	float	f1;
19:            	unsigned char	exp;
20:            	
21:            	if(c == 0)
22:            		return 0.0;
23:            	exp = 127+15;
24:            	// normalize 32 bits to 24 first
25:            	while(c & ~0xFFFFFFUL) {
26:            		c >>= 1;
27:            		exp++;
28:            	}
29:            	f1_as_mant1 = c;
30:            	__ftpack(&f1_as_mant1, exp);
31:            	return f1;
32:            }
33:            #else
34:            float
35:            __lltoft(unsigned long int c)
36:            {
37:            	unsigned char	exp;
38:            	exp = 127+15;
09E0  308E     MOVLW 0x8E
09E1  00F9     MOVWF c
09E2  0879     MOVF c, W
09E3  00FA     MOVWF row
39:            
40:            	// normalize 32 bits to 24 first
41:            	while(c & ~0xFFFFFFUL) {
09E4  30FF     MOVLW 0xFF
09E5  0020     MOVLB 0x0
09E6  0523     ANDWF f2, W
09E7  1903     BTFSC STATUS, 0x2
09E8  29F6     GOTO 0x1F6
09F5  29E4     GOTO 0x1E4
42:            		c >>= 1;
09E9  3001     MOVLW 0x1
09EA  0020     MOVLB 0x0
09EB  36A3     LSRF f2, F
09EC  0CA2     RRF i, F
09ED  0CA1     RRF data, F
09EE  0CA0     RRF __pcstackBANK0, F
09EF  0B89     DECFSZ WREG, F
09F0  29EA     GOTO 0x1EA
43:            		exp++;
09F1  3001     MOVLW 0x1
09F2  00F9     MOVWF c
09F3  0879     MOVF c, W
09F4  07FA     ADDWF row, F
44:            	}
45:            	return __ftpack((unsigned short long)c, exp, 0);
09F6  0820     MOVF __pcstackBANK0, W
09F7  00F1     MOVWF multiplier
09F8  0821     MOVF data, W
09F9  00F2     MOVWF val
09FA  0822     MOVF i, W
09FB  00F3     MOVWF multiplicand
09FC  087A     MOVF row, W
09FD  00F9     MOVWF c
09FE  0879     MOVF c, W
09FF  00F4     MOVWF ff2
0A00  01F5     CLRF product
0A01  318E     MOVLP 0xE
0A02  2600     CALL 0x600
0A03  0871     MOVF multiplier, W
0A04  0020     MOVLB 0x0
0A05  00A0     MOVWF __pcstackBANK0
0A06  0872     MOVF val, W
0A07  00A1     MOVWF data
0A08  0873     MOVF multiplicand, W
0A09  00A2     MOVWF i
0A0A  0008     RETURN
46:            }
0A0B  0020     MOVLB 0x0
0A0C  00A0     MOVWF __pcstackBANK0
0A0D  01A2     CLRF i
0A0E  3009     MOVLW 0x9
0A0F  0222     SUBWF i, W
0A10  1803     BTFSC STATUS, 0x0
0A11  0008     RETURN
47:            #endif
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/llmod.c  ----------------------------------------------
1:             // long unsigned unsigned modulus
2:             
3:             unsigned long int
4:             __llmod(unsigned long int divisor, unsigned long int dividend)
5:             {
6:             	unsigned char	counter;
7:             
8:             	if(divisor != 0) {
0BD3  0020     MOVLB 0x0
0BD4  0828     MOVF src, W
0BD5  0427     IORWF row, W
0BD6  0426     IORWF i, W
0BD7  0425     IORWF len, W
0BD8  1903     BTFSC STATUS, 0x2
0BD9  2C0D     GOTO 0x40D
0BDA  01FB     CLRF addr
0BDB  0AFB     INCF addr, F
0BDC  1BA8     BTFSC src, 0x7
0BDD  2BEA     GOTO 0x3EA
9:             		counter = 1;
0BDA  01FB     CLRF addr
0BDB  0AFB     INCF addr, F
10:            		while((divisor & 0x80000000UL) == 0) {
0BDC  1BA8     BTFSC src, 0x7
0BDD  2BEA     GOTO 0x3EA
0BDE  3001     MOVLW 0x1
0BE9  2BDC     GOTO 0x3DC
11:            			divisor <<= 1;
0BDE  3001     MOVLW 0x1
0BDF  35A5     LSLF len, F
0BE0  0DA6     RLF i, F
0BE1  0DA7     RLF row, F
0BE2  0DA8     RLF src, F
0BE3  0B89     DECFSZ WREG, F
0BE4  2BDF     GOTO 0x3DF
0BE5  3001     MOVLW 0x1
0BE6  00FA     MOVWF row
0BE7  087A     MOVF row, W
0BE8  07FB     ADDWF addr, F
12:            			counter++;
0BE5  3001     MOVLW 0x1
0BE6  00FA     MOVWF row
0BE7  087A     MOVF row, W
0BE8  07FB     ADDWF addr, F
0BE9  2BDC     GOTO 0x3DC
13:            		}
14:            		do {
15:            			if((unsigned long)divisor <= (unsigned long)dividend)
0BEA  0828     MOVF src, W
0BEB  022C     SUBWF cp, W
0BEC  1D03     BTFSS STATUS, 0x2
0BED  2BF8     GOTO 0x3F8
0BEE  0827     MOVF row, W
0BEF  022B     SUBWF f3_as_product, W
0BF0  1D03     BTFSS STATUS, 0x2
0BF1  2BF8     GOTO 0x3F8
0BF2  0826     MOVF i, W
0BF3  022A     SUBWF exp, W
0BF4  1D03     BTFSS STATUS, 0x2
0BF5  2BF8     GOTO 0x3F8
0BF6  0825     MOVF len, W
0BF7  0229     SUBWF dividend, W
0BF8  1C03     BTFSS STATUS, 0x0
0BF9  2C02     GOTO 0x402
16:            				dividend -= divisor;
0BFA  0825     MOVF len, W
0BFB  02A9     SUBWF dividend, F
0BFC  0826     MOVF i, W
0BFD  3BAA     SUBWFB exp, F
0BFE  0827     MOVF row, W
0BFF  3BAB     SUBWFB f3_as_product, F
0C00  0828     MOVF src, W
0C01  3BAC     SUBWFB cp, F
17:            			*(unsigned long int *)&divisor >>= 1;
0C02  3001     MOVLW 0x1
0C03  36A8     LSRF src, F
0C04  0CA7     RRF row, F
0C05  0CA6     RRF i, F
0C06  0CA5     RRF len, F
0C07  0B89     DECFSZ WREG, F
0C08  2C03     GOTO 0x403
18:            		} while(--counter != 0);
0C09  3001     MOVLW 0x1
0C0A  02FB     SUBWF addr, F
0C0B  1D03     BTFSS STATUS, 0x2
0C0C  2BEA     GOTO 0x3EA
19:            	}
20:            	return dividend;
0C0D  082C     MOVF cp, W
0C0E  00A8     MOVWF src
0C0F  082B     MOVF f3_as_product, W
0C10  00A7     MOVWF row
0C11  082A     MOVF exp, W
0C12  00A6     MOVWF i
0C13  0829     MOVF dividend, W
0C14  00A5     MOVWF len
0C15  0008     RETURN
21:            }
0C16  0020     MOVLB 0x0
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/lldiv.c  ----------------------------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             __lldiv(unsigned long int divisor, unsigned long int dividend)
5:             {
6:             	unsigned long int	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0CAD  3000     MOVLW 0x0
0CAE  0020     MOVLB 0x0
0CAF  00A3     MOVWF f2
0CB0  3000     MOVLW 0x0
0CB1  00A2     MOVWF i
0CB2  3000     MOVLW 0x0
0CB3  00A1     MOVWF data
0CB4  3000     MOVLW 0x0
0CB5  00A0     MOVWF __pcstackBANK0
10:            	if(divisor != 0) {
0CB6  0874     MOVF ff2, W
0CB7  0473     IORWF multiplicand, W
0CB8  0472     IORWF val, W
0CB9  0471     IORWF multiplier, W
0CBA  1903     BTFSC STATUS, 0x2
0CBB  2CF7     GOTO 0x4F7
11:            		counter = 1;
0CBC  01A4     CLRF counter
0CBD  0AA4     INCF counter, F
12:            		while((divisor & 0x80000000UL) == 0) {
0CBE  1BF4     BTFSC ff2, 0x7
0CBF  2CCC     GOTO 0x4CC
0CCB  2CBE     GOTO 0x4BE
13:            			divisor <<= 1;
0CC0  3001     MOVLW 0x1
0CC1  35F1     LSLF multiplier, F
0CC2  0DF2     RLF val, F
0CC3  0DF3     RLF multiplicand, F
0CC4  0DF4     RLF ff2, F
0CC5  0B89     DECFSZ WREG, F
0CC6  2CC1     GOTO 0x4C1
14:            			counter++;
0CC7  3001     MOVLW 0x1
0CC8  00F9     MOVWF c
0CC9  0879     MOVF c, W
0CCA  07A4     ADDWF counter, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0CCC  3001     MOVLW 0x1
0CCD  35A0     LSLF __pcstackBANK0, F
0CCE  0DA1     RLF data, F
0CCF  0DA2     RLF i, F
0CD0  0DA3     RLF f2, F
0CD1  0B89     DECFSZ WREG, F
0CD2  2CCD     GOTO 0x4CD
18:            			if(divisor <= dividend) {
0CD3  0874     MOVF ff2, W
0CD4  0278     SUBWF col, W
0CD5  1D03     BTFSS STATUS, 0x2
0CD6  2CE1     GOTO 0x4E1
0CD7  0873     MOVF multiplicand, W
0CD8  0277     SUBWF rs, W
0CD9  1D03     BTFSS STATUS, 0x2
0CDA  2CE1     GOTO 0x4E1
0CDB  0872     MOVF val, W
0CDC  0276     SUBWF bf, W
0CDD  1D03     BTFSS STATUS, 0x2
0CDE  2CE1     GOTO 0x4E1
0CDF  0871     MOVF multiplier, W
0CE0  0275     SUBWF product, W
0CE1  1C03     BTFSS STATUS, 0x0
0CE2  2CEC     GOTO 0x4EC
19:            				dividend -= divisor;
0CE3  0871     MOVF multiplier, W
0CE4  02F5     SUBWF product, F
0CE5  0872     MOVF val, W
0CE6  3BF6     SUBWFB bf, F
0CE7  0873     MOVF multiplicand, W
0CE8  3BF7     SUBWFB rs, F
0CE9  0874     MOVF ff2, W
0CEA  3BF8     SUBWFB col, F
20:            				quotient |= 1;
0CEB  1420     BSF __pcstackBANK0, 0x0
21:            			}
22:            			divisor >>= 1;
0CEC  3001     MOVLW 0x1
0CED  36F4     LSRF ff2, F
0CEE  0CF3     RRF multiplicand, F
0CEF  0CF2     RRF val, F
0CF0  0CF1     RRF multiplier, F
0CF1  0B89     DECFSZ WREG, F
0CF2  2CED     GOTO 0x4ED
23:            		} while(--counter != 0);
0CF3  3001     MOVLW 0x1
0CF4  02A4     SUBWF counter, F
0CF5  1D03     BTFSS STATUS, 0x2
0CF6  2CCC     GOTO 0x4CC
24:            	}
25:            	return quotient;
0CF7  0823     MOVF f2, W
0CF8  00F4     MOVWF ff2
0CF9  0822     MOVF i, W
0CFA  00F3     MOVWF multiplicand
0CFB  0821     MOVF data, W
0CFC  00F2     MOVWF val
0CFD  0820     MOVF __pcstackBANK0, W
0CFE  00F1     MOVWF multiplier
0CFF  0008     RETURN
26:            }
0D00  01F7     CLRF rs
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/lbtoft.c  ---------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert byte to float
12:            #ifdef _OLDLIB
13:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
14:            float
15:            __lbtoft(unsigned char c)
16:            {
17:            	float	f1;
18:            	
19:            	if(c == 0)
20:            		return 0.0;
21:            	f1_as_mant1 = c;
22:            	__ftpack(&f1_as_mant1, 127+15);
23:            	return f1;
24:            }
25:            #else
26:            float
27:            __lbtoft(unsigned char c)
28:            {
1739  0020     MOVLB 0x0
173A  00A4     MOVWF counter
29:            	return __ftpack(c, 127+15, 0);
173B  0824     MOVF counter, W
173C  00A0     MOVWF __pcstackBANK0
173D  01A1     CLRF data
173E  01A2     CLRF i
173F  0820     MOVF __pcstackBANK0, W
1740  00F1     MOVWF multiplier
1741  0821     MOVF data, W
1742  00F2     MOVWF val
1743  0822     MOVF i, W
1744  00F3     MOVWF multiplicand
1745  308E     MOVLW 0x8E
1746  00A3     MOVWF f2
1747  0823     MOVF f2, W
1748  00F4     MOVWF ff2
1749  01F5     CLRF product
174A  318E     MOVLP 0xE
174B  2600     CALL 0x600
174C  0871     MOVF multiplier, W
174D  00F9     MOVWF c
174E  0872     MOVF val, W
174F  00FA     MOVWF row
1750  0873     MOVF multiplicand, W
1751  00FB     MOVWF addr
1752  0008     RETURN
30:            }
1753  0022     MOVLB 0x2
1754  01CA     CLRF pktTx
31:            #endif
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/fttol.c  ----------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
0ED6  0020     MOVLB 0x0
0ED7  0830     MOVF f1, W
0ED8  00B4     MOVWF 0x34
0ED9  0831     MOVF 0x31, W
0EDA  00B5     MOVWF 0x35
0EDB  0832     MOVF 0x32, W
0EDC  00B6     MOVWF 0x36
0EDD  1003     BCF STATUS, 0x0
0EDE  0D35     RLF 0x35, W
0EDF  0D36     RLF 0x36, W
0EE0  00B7     MOVWF 0x37
0EE1  0837     MOVF 0x37, W
0EE2  00BD     MOVWF exp1
0EE3  08BD     MOVF exp1, F
0EE4  1D03     BTFSS STATUS, 0x2
0EE5  2EEF     GOTO 0x6EF
50:            		return 0;
0EE6  3000     MOVLW 0x0
0EE7  00B3     MOVWF 0x33
0EE8  3000     MOVLW 0x0
0EE9  00B2     MOVWF 0x32
0EEA  3000     MOVLW 0x0
0EEB  00B1     MOVWF 0x31
0EEC  3000     MOVLW 0x0
0EED  00B0     MOVWF f1
0EEE  0008     RETURN
51:            	sign1 = f1_as_mant1 >> 23;
0EEF  0830     MOVF f1, W
0EF0  00B4     MOVWF 0x34
0EF1  0831     MOVF 0x31, W
0EF2  00B5     MOVWF 0x35
0EF3  0832     MOVF 0x32, W
0EF4  00B6     MOVWF 0x36
0EF5  3017     MOVLW 0x17
0EF6  36B6     LSRF 0x36, F
0EF7  0CB5     RRF 0x35, F
0EF8  0CB4     RRF 0x34, F
0EF9  0B89     DECFSZ WREG, F
0EFA  2EF6     GOTO 0x6F6
0EFB  0834     MOVF 0x34, W
0EFC  00B7     MOVWF 0x37
0EFD  0837     MOVF 0x37, W
0EFE  00B8     MOVWF sign1
52:            	f1_as_mant1 |= 0x8000UL;
0EFF  17B1     BSF 0x31, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
0F00  30FF     MOVLW 0xFF
0F01  05B0     ANDWF f1, F
0F02  30FF     MOVLW 0xFF
0F03  05B1     ANDWF 0x31, F
0F04  3000     MOVLW 0x0
0F05  05B2     ANDWF 0x32, F
54:            	lval = f1_as_mant1;
0F06  0830     MOVF f1, W
0F07  00B9     MOVWF lval
0F08  0831     MOVF 0x31, W
0F09  00BA     MOVWF 0x3A
0F0A  0832     MOVF 0x32, W
0F0B  00BB     MOVWF flag
0F0C  01BC     CLRF ap
55:            	exp1 -= 127+15;
0F0D  308E     MOVLW 0x8E
0F0E  02BD     SUBWF exp1, F
56:            	if((signed char)exp1 < 0) {
0F0F  1FBD     BTFSS exp1, 0x7
0F10  2F2D     GOTO 0x72D
57:            		if((signed char)exp1 < -15)
0F11  083D     MOVF exp1, W
0F12  3A80     XORLW 0x80
0F13  3E8F     ADDLW 0x8F
0F14  1803     BTFSC STATUS, 0x0
0F15  2F1F     GOTO 0x71F
58:            			return 0;
0F16  3000     MOVLW 0x0
0F17  00B3     MOVWF 0x33
0F18  3000     MOVLW 0x0
0F19  00B2     MOVWF 0x32
0F1A  3000     MOVLW 0x0
0F1B  00B1     MOVWF 0x31
0F1C  3000     MOVLW 0x0
0F1D  00B0     MOVWF f1
0F1E  0008     RETURN
59:            		do
60:            			lval >>= 1;
0F1F  3001     MOVLW 0x1
0F20  36BC     LSRF ap, F
0F21  0CBB     RRF flag, F
0F22  0CBA     RRF 0x3A, F
0F23  0CB9     RRF lval, F
0F24  0B89     DECFSZ WREG, F
0F25  2F20     GOTO 0x720
61:            		while(++exp1 != 0);
0F26  3001     MOVLW 0x1
0F27  00B4     MOVWF 0x34
0F28  0834     MOVF 0x34, W
0F29  07BD     ADDWF exp1, F
0F2A  1903     BTFSC STATUS, 0x2
0F2B  2F46     GOTO 0x746
0F2C  2F1F     GOTO 0x71F
62:            	} else {
63:            		if(exp1 >= 24)
0F2D  3018     MOVLW 0x18
0F2E  023D     SUBWF exp1, W
0F2F  1C03     BTFSS STATUS, 0x0
0F30  2F43     GOTO 0x743
64:            			return 0;
0F31  3000     MOVLW 0x0
0F32  00B3     MOVWF 0x33
0F33  3000     MOVLW 0x0
0F34  00B2     MOVWF 0x32
0F35  3000     MOVLW 0x0
0F36  00B1     MOVWF 0x31
0F37  3000     MOVLW 0x0
0F38  00B0     MOVWF f1
0F39  0008     RETURN
65:            		while(exp1 != 0) {
0F43  08BD     MOVF exp1, F
0F44  1D03     BTFSS STATUS, 0x2
0F45  2F3A     GOTO 0x73A
66:            			lval <<= 1;
0F3A  3001     MOVLW 0x1
0F3B  35B9     LSLF lval, F
0F3C  0DBA     RLF 0x3A, F
0F3D  0DBB     RLF flag, F
0F3E  0DBC     RLF ap, F
0F3F  0B89     DECFSZ WREG, F
0F40  2F3B     GOTO 0x73B
67:            			exp1--;
0F41  3001     MOVLW 0x1
0F42  02BD     SUBWF exp1, F
68:            		}
69:            	}
70:            	if(sign1)
0F46  0838     MOVF sign1, W
0F47  1903     BTFSC STATUS, 0x2
0F48  2F54     GOTO 0x754
71:            		lval = -lval;
0F49  09B9     COMF lval, F
0F4A  09BA     COMF 0x3A, F
0F4B  09BB     COMF flag, F
0F4C  09BC     COMF ap, F
0F4D  0AB9     INCF lval, F
0F4E  1903     BTFSC STATUS, 0x2
0F4F  0ABA     INCF 0x3A, F
0F50  1903     BTFSC STATUS, 0x2
0F51  0ABB     INCF flag, F
0F52  1903     BTFSC STATUS, 0x2
0F53  0ABC     INCF ap, F
72:            	return lval;
0F54  083C     MOVF ap, W
0F55  00B3     MOVWF 0x33
0F56  083B     MOVF flag, W
0F57  00B2     MOVWF 0x32
0F58  083A     MOVF 0x3A, W
0F59  00B1     MOVWF 0x31
0F5A  0839     MOVF lval, W
0F5B  00B0     MOVWF f1
0F5C  0008     RETURN
73:            }
0F5D  3020     MOVLW 0x20
74:            #endif
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/ftsub.c  ----------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            __ftsub(float f2, float f1)
17:            {
18:            	f2_as_mant2 ^= 0x800000;
1706  3080     MOVLW 0x80
1707  0020     MOVLB 0x0
1708  06AC     XORWF cp, F
19:            	return __ftadd(f1, f2);
1709  082D     MOVF f1, W
170A  00A0     MOVWF __pcstackBANK0
170B  082E     MOVF cntr, W
170C  00A1     MOVWF data
170D  082F     MOVF sign, W
170E  00A2     MOVWF i
170F  082A     MOVF exp, W
1710  00A3     MOVWF f2
1711  082B     MOVF f3_as_product, W
1712  00A4     MOVWF counter
1713  082C     MOVF cp, W
1714  00A5     MOVWF len
1715  3184     MOVLP 0x4
1716  24C6     CALL 0x4C6
1717  0020     MOVLB 0x0
1718  0820     MOVF __pcstackBANK0, W
1719  00AA     MOVWF exp
171A  0821     MOVF data, W
171B  00AB     MOVWF f3_as_product
171C  0822     MOVF i, W
171D  00AC     MOVWF cp
171E  0008     RETURN
20:            }
171F  0020     MOVLB 0x0
1720  00E6     MOVWF state
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/ftoa.c  -----------------------------------------------
1:             #include	<stdlib.h>
2:             #include	<stdio.h>
3:             
4:             // quick and dirty ftoa for legacy code
5:             char *
6:             ftoa(float f, int * status)
7:             {
8:             	static char		buf[17];
9:             	char *			cp = buf;
0F5D  3020     MOVLW 0x20
0F5E  0020     MOVLB 0x0
0F5F  00CB     MOVWF 0x4B
0F60  084B     MOVF 0x4B, W
0F61  00D4     MOVWF cp
10:            	unsigned long	l, rem;
11:            
12:            	if(f < 0) {
0F62  0847     MOVF f, W
0F63  00F1     MOVWF multiplier
0F64  0848     MOVF 0x48, W
0F65  00F2     MOVWF val
0F66  0849     MOVF 0x49, W
0F67  00F3     MOVWF multiplicand
0F68  3000     MOVLW 0x0
0F69  00F4     MOVWF ff2
0F6A  3000     MOVLW 0x0
0F6B  00F5     MOVWF product
0F6C  3000     MOVLW 0x0
0F6D  00F6     MOVWF bf
0F6E  318B     MOVLP 0xB
0F6F  2358     CALL 0x358
0F70  318F     MOVLP 0xF
0F71  1803     BTFSC STATUS, 0x0
0F72  2F90     GOTO 0x790
13:            		*cp++ = '-';
0F73  302D     MOVLW 0x2D
0F74  0020     MOVLB 0x0
0F75  00CB     MOVWF 0x4B
0F76  0854     MOVF cp, W
0F77  0086     MOVWF FSR1
0F78  3001     MOVLW 0x1
0F79  0087     MOVWF FSR1H
0F7A  084B     MOVF 0x4B, W
0F7B  0081     MOVWF INDF1
0F7C  3001     MOVLW 0x1
0F7D  00CB     MOVWF 0x4B
0F7E  084B     MOVF 0x4B, W
0F7F  07D4     ADDWF cp, F
14:            		f = -f;
0F80  0847     MOVF f, W
0F81  00F1     MOVWF multiplier
0F82  0848     MOVF 0x48, W
0F83  00F2     MOVWF val
0F84  0849     MOVF 0x49, W
0F85  00F3     MOVWF multiplicand
0F86  3195     MOVLP 0x15
0F87  25A3     CALL 0x5A3
0F88  318F     MOVLP 0xF
0F89  0871     MOVF multiplier, W
0F8A  0020     MOVLB 0x0
0F8B  00C7     MOVWF f
0F8C  0872     MOVF val, W
0F8D  00C8     MOVWF 0x48
0F8E  0873     MOVF multiplicand, W
0F8F  00C9     MOVWF 0x49
15:            	}
16:            	l = (unsigned long)f;
0F90  0020     MOVLB 0x0
0F91  0847     MOVF f, W
0F92  00B0     MOVWF f1
0F93  0848     MOVF 0x48, W
0F94  00B1     MOVWF 0x31
0F95  0849     MOVF 0x49, W
0F96  00B2     MOVWF 0x32
0F97  318E     MOVLP 0xE
0F98  26D6     CALL 0x6D6
0F99  318F     MOVLP 0xF
0F9A  0020     MOVLB 0x0
0F9B  0833     MOVF 0x33, W
0F9C  00D3     MOVWF 0x53
0F9D  0832     MOVF 0x32, W
0F9E  00D2     MOVWF 0x52
0F9F  0831     MOVF 0x31, W
0FA0  00D1     MOVWF 0x51
0FA1  0830     MOVF f1, W
0FA2  00D0     MOVWF l
17:            	f -= (float)l;
0FA3  0853     MOVF 0x53, W
0FA4  00A3     MOVWF f2
0FA5  0852     MOVF 0x52, W
0FA6  00A2     MOVWF i
0FA7  0851     MOVF 0x51, W
0FA8  00A1     MOVWF data
0FA9  0850     MOVF l, W
0FAA  00A0     MOVWF __pcstackBANK0
0FAB  3189     MOVLP 0x9
0FAC  21E0     CALL 0x1E0
0FAD  318F     MOVLP 0xF
0FAE  0020     MOVLB 0x0
0FAF  0820     MOVF __pcstackBANK0, W
0FB0  00AA     MOVWF exp
0FB1  0821     MOVF data, W
0FB2  00AB     MOVWF f3_as_product
0FB3  0822     MOVF i, W
0FB4  00AC     MOVWF cp
0FB5  0847     MOVF f, W
0FB6  00AD     MOVWF f1
0FB7  0848     MOVF 0x48, W
0FB8  00AE     MOVWF cntr
0FB9  0849     MOVF 0x49, W
0FBA  00AF     MOVWF sign
0FBB  3197     MOVLP 0x17
0FBC  2706     CALL 0x706
0FBD  318F     MOVLP 0xF
0FBE  0020     MOVLB 0x0
0FBF  082A     MOVF exp, W
0FC0  00C7     MOVWF f
0FC1  082B     MOVF f3_as_product, W
0FC2  00C8     MOVWF 0x48
0FC3  082C     MOVF cp, W
0FC4  00C9     MOVWF 0x49
18:            	rem = (unsigned long)(f * 1e6);
0FC5  0847     MOVF f, W
0FC6  00A3     MOVWF f2
0FC7  0848     MOVF 0x48, W
0FC8  00A4     MOVWF counter
0FC9  0849     MOVF 0x49, W
0FCA  00A5     MOVWF len
0FCB  3024     MOVLW 0x24
0FCC  00A0     MOVWF __pcstackBANK0
0FCD  3074     MOVLW 0x74
0FCE  00A1     MOVWF data
0FCF  3049     MOVLW 0x49
0FD0  00A2     MOVWF i
0FD1  3187     MOVLP 0x7
0FD2  2747     CALL 0x747
0FD3  318F     MOVLP 0xF
0FD4  0020     MOVLB 0x0
0FD5  0820     MOVF __pcstackBANK0, W
0FD6  00B0     MOVWF f1
0FD7  0821     MOVF data, W
0FD8  00B1     MOVWF 0x31
0FD9  0822     MOVF i, W
0FDA  00B2     MOVWF 0x32
0FDB  318E     MOVLP 0xE
0FDC  26D6     CALL 0x6D6
0FDD  318F     MOVLP 0xF
0FDE  0020     MOVLB 0x0
0FDF  0833     MOVF 0x33, W
0FE0  00CF     MOVWF 0x4F
0FE1  0832     MOVF 0x32, W
0FE2  00CE     MOVWF 0x4E
0FE3  0831     MOVF 0x31, W
0FE4  00CD     MOVWF 0x4D
0FE5  0830     MOVF f1, W
0FE6  00CC     MOVWF rem
19:            	sprintf(cp, "%lu.%6.6lu", l, rem);
0FE7  302E     MOVLW 0x2E
0FE8  00CB     MOVWF 0x4B
0FE9  084B     MOVF 0x4B, W
0FEA  00AD     MOVWF f1
0FEB  0853     MOVF 0x53, W
0FEC  00B1     MOVWF 0x31
0FED  0852     MOVF 0x52, W
0FEE  00B0     MOVWF f1
0FEF  0851     MOVF 0x51, W
0FF0  00AF     MOVWF sign
0FF1  0850     MOVF l, W
0FF2  00AE     MOVWF cntr
0FF3  084F     MOVF 0x4F, W
0FF4  00B5     MOVWF 0x35
0FF5  084E     MOVF 0x4E, W
0FF6  00B4     MOVWF 0x34
0FF7  084D     MOVF 0x4D, W
0FF8  00B3     MOVWF 0x33
0FF9  084C     MOVF rem, W
0FFA  00B2     MOVWF 0x32
0FFB  0854     MOVF cp, W
0FFC  3182     MOVLP 0x2
0FFD  22EA     CALL 0x2EA
20:            	return buf;
0FFE  3020     MOVLW 0x20
0FFF  0008     RETURN
21:            }
1000  3FFF     MOVWI [-1]FSR1
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/ftneg.c  ----------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(unsigned short long *)&f1)
11:            
12:            // Negate a float
13:            
14:            float
15:            __ftneg(float f1)
16:            {
17:            	if(f1 != 0)
15A3  0873     MOVF multiplicand, W
15A4  0472     IORWF val, W
15A5  0471     IORWF multiplier, W
15A6  1903     BTFSC STATUS, 0x2
15A7  0008     RETURN
18:            		mant1 ^= 0x800000UL;
15A8  3080     MOVLW 0x80
15A9  06F3     XORWF multiplicand, F
19:            	return f1;
20:            }
15AA  0008     RETURN
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/ftmul.c  ----------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned short long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            #ifdef _OLDLIB
16:            #define	f3_as_product		(*(unsigned short long *)&f3)
17:            float
18:            __ftmul(float f1, float f2)
19:            {
20:            	unsigned char	exp1, sign1, cntr;
21:            	float	f3;
22:            	
23:            	f3_as_product = 0;
24:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
25:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
26:            	if(cntr == 0 || exp1 == 0)
27:            		return f3;
28:            	exp1 += cntr-127-6;	// compute new exponent
29:            	cntr = 7;
30:            	do {
31:            		if(f1_as_plier & 1)
32:            			f3_as_product += f2_as_plicand;
33:            		f1_as_plier >>= 1;
34:            		f2_as_plicand <<= 1;
35:            	} while(--cntr != 0);
36:            	cntr = 9;
37:            	do {
38:            		if(f1_as_plier & 1)
39:            			f3_as_product += f2_as_plicand;
40:            		f1_as_plier >>= 1;
41:            		f3_as_product >>= 1;
42:            	} while(--cntr != 0);
43:            	__ftpack(&f3_as_product, exp1);
44:            	if(sign1)
45:            		f3_as_product |= 0x800000;
46:            	return f3;
47:            }
48:            #else
49:            #define	exp2	sign
50:            float
51:            __ftmul(float f1, float f2)
52:            {
53:            	unsigned char	exp, sign, cntr;
54:            	unsigned short long	f3_as_product;
55:            
56:            	if((exp = f1_as_plier >> 15) == 0)
0747  0020     MOVLB 0x0
0748  0820     MOVF __pcstackBANK0, W
0749  00A6     MOVWF i
074A  0821     MOVF data, W
074B  00A7     MOVWF row
074C  0822     MOVF i, W
074D  00A8     MOVWF src
074E  1003     BCF STATUS, 0x0
074F  0D27     RLF row, W
0750  0D28     RLF src, W
0751  00A9     MOVWF dividend
0752  0829     MOVF dividend, W
0753  00AA     MOVWF exp
0754  08AA     MOVF exp, F
0755  1D03     BTFSS STATUS, 0x2
0756  2F5E     GOTO 0x75E
57:            		return 0.0;
0757  3000     MOVLW 0x0
0758  00A0     MOVWF __pcstackBANK0
0759  3000     MOVLW 0x0
075A  00A1     MOVWF data
075B  3000     MOVLW 0x0
075C  00A2     MOVWF i
075D  0008     RETURN
58:            	if((exp2 = f2_as_plicand >> 15) == 0)
075E  0823     MOVF f2, W
075F  00A6     MOVWF i
0760  0824     MOVF counter, W
0761  00A7     MOVWF row
0762  0825     MOVF len, W
0763  00A8     MOVWF src
0764  1003     BCF STATUS, 0x0
0765  0D27     RLF row, W
0766  0D28     RLF src, W
0767  00A9     MOVWF dividend
0768  0829     MOVF dividend, W
0769  00AF     MOVWF sign
076A  08AF     MOVF sign, F
076B  1D03     BTFSS STATUS, 0x2
076C  2F74     GOTO 0x774
59:            		return 0.0;
076D  3000     MOVLW 0x0
076E  00A0     MOVWF __pcstackBANK0
076F  3000     MOVLW 0x0
0770  00A1     MOVWF data
0771  3000     MOVLW 0x0
0772  00A2     MOVWF i
0773  0008     RETURN
60:            	exp += exp2-127-6;	// compute new exponent
0774  082F     MOVF sign, W
0775  3E7B     ADDLW 0x7B
0776  00A6     MOVWF i
0777  0826     MOVF i, W
0778  07AA     ADDWF exp, F
61:            	sign = f1_as_plier >> 16;
0779  0820     MOVF __pcstackBANK0, W
077A  00A6     MOVWF i
077B  0821     MOVF data, W
077C  00A7     MOVWF row
077D  0822     MOVF i, W
077E  00A8     MOVWF src
077F  3010     MOVLW 0x10
0780  36A8     LSRF src, F
0781  0CA7     RRF row, F
0782  0CA6     RRF i, F
0783  0B89     DECFSZ WREG, F
0784  2F80     GOTO 0x780
0785  0826     MOVF i, W
0786  00A9     MOVWF dividend
0787  0829     MOVF dividend, W
0788  00AF     MOVWF sign
62:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
0789  0823     MOVF f2, W
078A  00A6     MOVWF i
078B  0824     MOVF counter, W
078C  00A7     MOVWF row
078D  0825     MOVF len, W
078E  00A8     MOVWF src
078F  3010     MOVLW 0x10
0790  36A8     LSRF src, F
0791  0CA7     RRF row, F
0792  0CA6     RRF i, F
0793  0B89     DECFSZ WREG, F
0794  2F90     GOTO 0x790
0795  0826     MOVF i, W
0796  00A9     MOVWF dividend
0797  0829     MOVF dividend, W
0798  06AF     XORWF sign, F
63:            	sign &= 0x80;
0799  3080     MOVLW 0x80
079A  00A6     MOVWF i
079B  0826     MOVF i, W
079C  05AF     ANDWF sign, F
64:            	f1_as_plier |= 0x8000UL;
079D  17A1     BSF data, 0x7
65:            	//f1_as_plier &= 0xFFFFUL;		// not required
66:            	f2_as_plicand |= 0x8000UL;
079E  17A4     BSF counter, 0x7
67:            	f2_as_plicand &= 0xFFFFUL;
079F  30FF     MOVLW 0xFF
07A0  05A3     ANDWF f2, F
07A1  30FF     MOVLW 0xFF
07A2  05A4     ANDWF counter, F
07A3  3000     MOVLW 0x0
07A4  05A5     ANDWF len, F
68:            	f3_as_product = 0;
07A5  3000     MOVLW 0x0
07A6  00AB     MOVWF f3_as_product
07A7  3000     MOVLW 0x0
07A8  00AC     MOVWF cp
07A9  3000     MOVLW 0x0
07AA  00AD     MOVWF f1
69:            	cntr = 7;
07AB  3007     MOVLW 0x7
07AC  00A6     MOVWF i
07AD  0826     MOVF i, W
07AE  00AE     MOVWF cntr
70:            	do {
71:            		if(f1_as_plier & 1)
07AF  1C20     BTFSS __pcstackBANK0, 0x0
07B0  2FB7     GOTO 0x7B7
72:            			f3_as_product += f2_as_plicand;
07B1  0823     MOVF f2, W
07B2  07AB     ADDWF f3_as_product, F
07B3  0824     MOVF counter, W
07B4  3DAC     ADDWFC cp, F
07B5  0825     MOVF len, W
07B6  3DAD     ADDWFC f1, F
73:            		f1_as_plier >>= 1;
07B7  3001     MOVLW 0x1
07B8  36A2     LSRF i, F
07B9  0CA1     RRF data, F
07BA  0CA0     RRF __pcstackBANK0, F
07BB  0B89     DECFSZ WREG, F
07BC  2FB8     GOTO 0x7B8
74:            		f2_as_plicand <<= 1;
07BD  3001     MOVLW 0x1
07BE  35A3     LSLF f2, F
07BF  0DA4     RLF counter, F
07C0  0DA5     RLF len, F
07C1  0B89     DECFSZ WREG, F
07C2  2FBE     GOTO 0x7BE
75:            	} while(--cntr != 0);
07C3  3001     MOVLW 0x1
07C4  02AE     SUBWF cntr, F
07C5  1D03     BTFSS STATUS, 0x2
07C6  2FAF     GOTO 0x7AF
76:            	cntr = 9;
07C7  3009     MOVLW 0x9
07C8  00A6     MOVWF i
07C9  0826     MOVF i, W
07CA  00AE     MOVWF cntr
77:            	do {
78:            		if(f1_as_plier & 1)
07CB  1C20     BTFSS __pcstackBANK0, 0x0
07CC  2FD3     GOTO 0x7D3
79:            			f3_as_product += f2_as_plicand;
07CD  0823     MOVF f2, W
07CE  07AB     ADDWF f3_as_product, F
07CF  0824     MOVF counter, W
07D0  3DAC     ADDWFC cp, F
07D1  0825     MOVF len, W
07D2  3DAD     ADDWFC f1, F
80:            		f1_as_plier >>= 1;
07D3  3001     MOVLW 0x1
07D4  36A2     LSRF i, F
07D5  0CA1     RRF data, F
07D6  0CA0     RRF __pcstackBANK0, F
07D7  0B89     DECFSZ WREG, F
07D8  2FD4     GOTO 0x7D4
81:            		f3_as_product >>= 1;
07D9  3001     MOVLW 0x1
07DA  36AD     LSRF f1, F
07DB  0CAC     RRF cp, F
07DC  0CAB     RRF f3_as_product, F
07DD  0B89     DECFSZ WREG, F
07DE  2FDA     GOTO 0x7DA
82:            	} while(--cntr != 0);
07DF  3001     MOVLW 0x1
07E0  02AE     SUBWF cntr, F
07E1  1D03     BTFSS STATUS, 0x2
07E2  2FCB     GOTO 0x7CB
83:            	return __ftpack(f3_as_product, exp, sign);
07E3  082B     MOVF f3_as_product, W
07E4  00F1     MOVWF multiplier
07E5  082C     MOVF cp, W
07E6  00F2     MOVWF val
07E7  082D     MOVF f1, W
07E8  00F3     MOVWF multiplicand
07E9  082A     MOVF exp, W
07EA  00A6     MOVWF i
07EB  0826     MOVF i, W
07EC  00F4     MOVWF ff2
07ED  082F     MOVF sign, W
07EE  00A7     MOVWF row
07EF  0827     MOVF row, W
07F0  00F5     MOVWF product
07F1  318E     MOVLP 0xE
07F2  2600     CALL 0x600
07F3  0871     MOVF multiplier, W
07F4  0020     MOVLB 0x0
07F5  00A0     MOVWF __pcstackBANK0
07F6  0872     MOVF val, W
07F7  00A1     MOVWF data
07F8  0873     MOVF multiplicand, W
07F9  00A2     MOVWF i
07FA  0008     RETURN
84:            }
07FB  3FFF     MOVWI [-1]FSR1
85:            #endif
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/ftge.c  -----------------------------------------------
1:             #define	f1	(*(unsigned short long *)&ff1)
2:             #define	f2	(*(unsigned short long *)&ff2)
3:             bit
4:             __ftge(float ff1, float ff2)
5:             {
6:             	if(f1 &  0x800000UL)
0B58  1FF3     BTFSS multiplicand, 0x7
7:             		f1 = 0x800000UL - f1;
0B5A  0971     COMF multiplier, W
0B5B  00F7     MOVWF rs
0B5C  0972     COMF val, W
0B5D  00F8     MOVWF col
0B5E  0973     COMF multiplicand, W
0B5F  00F9     MOVWF c
0B60  0AF7     INCF rs, F
0B61  1903     BTFSC STATUS, 0x2
0B62  0AF8     INCF col, F
0B63  1903     BTFSC STATUS, 0x2
0B64  0AF9     INCF c, F
0B65  3000     MOVLW 0x0
0B66  0777     ADDWF rs, W
0B67  00F1     MOVWF multiplier
0B68  3000     MOVLW 0x0
0B69  3D78     ADDWFC col, W
0B6A  00F2     MOVWF val
0B6B  3080     MOVLW 0x80
0B6C  3D79     ADDWFC c, W
0B6D  00F3     MOVWF multiplicand
8:             	if(f2 &  0x800000UL)
0B6E  1FF6     BTFSS bf, 0x7
0B6F  2B84     GOTO 0x384
9:             		f2 = 0x800000UL - f2;
0B70  0974     COMF ff2, W
0B71  00F7     MOVWF rs
0B72  0975     COMF product, W
0B73  00F8     MOVWF col
0B74  0976     COMF bf, W
0B75  00F9     MOVWF c
0B76  0AF7     INCF rs, F
0B77  1903     BTFSC STATUS, 0x2
0B78  0AF8     INCF col, F
0B79  1903     BTFSC STATUS, 0x2
0B7A  0AF9     INCF c, F
0B7B  3000     MOVLW 0x0
0B7C  0777     ADDWF rs, W
0B7D  00F4     MOVWF ff2
0B7E  3000     MOVLW 0x0
0B7F  3D78     ADDWFC col, W
0B80  00F5     MOVWF product
0B81  3080     MOVLW 0x80
0B82  3D79     ADDWFC c, W
0B83  00F6     MOVWF bf
10:            	f1 ^= 0x800000UL;
0B84  3080     MOVLW 0x80
0B85  06F3     XORWF multiplicand, F
11:            	f2 ^= 0x800000UL;
0B86  3080     MOVLW 0x80
0B87  06F6     XORWF bf, F
12:            	return f1 >= f2;
0B88  0876     MOVF bf, W
0B89  0273     SUBWF multiplicand, W
0B8A  1D03     BTFSS STATUS, 0x2
0B8B  0008     RETURN
0B8C  0875     MOVF product, W
0B8D  0272     SUBWF val, W
0B8E  1D03     BTFSS STATUS, 0x2
0B8F  0008     RETURN
0B90  0874     MOVF ff2, W
0B91  0271     SUBWF multiplier, W
0B92  0008     RETURN
13:            }
0B93  300F     MOVLW 0xF
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/ftadd.c  ----------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
04C6  0020     MOVLB 0x0
04C7  0820     MOVF __pcstackBANK0, W
04C8  00A6     MOVWF i
04C9  0821     MOVF data, W
04CA  00A7     MOVWF row
04CB  0822     MOVF i, W
04CC  00A8     MOVWF src
04CD  1003     BCF STATUS, 0x0
04CE  0D27     RLF row, W
04CF  0D28     RLF src, W
04D0  00A9     MOVWF dividend
04D1  0829     MOVF dividend, W
04D2  00FB     MOVWF addr
91:            	exp2 = f2_as_mant2 >> 15;
04D3  0823     MOVF f2, W
04D4  00A6     MOVWF i
04D5  0824     MOVF counter, W
04D6  00A7     MOVWF row
04D7  0825     MOVF len, W
04D8  00A8     MOVWF src
04D9  1003     BCF STATUS, 0x0
04DA  0D27     RLF row, W
04DB  0D28     RLF src, W
04DC  00A9     MOVWF dividend
04DD  0829     MOVF dividend, W
04DE  00FA     MOVWF row
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
04DF  087B     MOVF addr, W
04E0  1903     BTFSC STATUS, 0x2
04E1  2CEE     GOTO 0x4EE
04E2  087A     MOVF row, W
04E3  027B     SUBWF addr, W
04E4  1803     BTFSC STATUS, 0x0
04E5  2CF5     GOTO 0x4F5
04E6  037B     DECF addr, W
04E7  3AFF     XORLW 0xFF
04E8  077A     ADDWF row, W
04E9  00A6     MOVWF i
04EA  3019     MOVLW 0x19
04EB  0226     SUBWF i, W
04EC  1C03     BTFSS STATUS, 0x0
04ED  2CF5     GOTO 0x4F5
93:            		return f2;
04EE  0823     MOVF f2, W
04EF  00A0     MOVWF __pcstackBANK0
04F0  0824     MOVF counter, W
04F1  00A1     MOVWF data
04F2  0825     MOVF len, W
04F3  00A2     MOVWF i
04F4  0008     RETURN
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
04F5  087A     MOVF row, W
04F6  1903     BTFSC STATUS, 0x2
04F7  0008     RETURN
04F8  087B     MOVF addr, W
04F9  027A     SUBWF row, W
04FA  1803     BTFSC STATUS, 0x0
04FB  2D04     GOTO 0x504
04FC  037A     DECF row, W
04FD  3AFF     XORLW 0xFF
04FE  077B     ADDWF addr, W
04FF  00A6     MOVWF i
0500  3019     MOVLW 0x19
0501  0226     SUBWF i, W
0502  1803     BTFSC STATUS, 0x0
0503  0008     RETURN
95:            		return f1;
96:            	sign = 6;
0504  3006     MOVLW 0x6
0505  00A6     MOVWF i
0506  0826     MOVF i, W
0507  00F9     MOVWF c
97:            	if(f1_as_mant1 & 0x800000L)
0508  1BA2     BTFSC i, 0x7
98:            		sign |= 0x80;
0509  17F9     BSF c, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
050A  1BA5     BTFSC len, 0x7
100:           		sign |= 0x40;
050B  1779     BSF c, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
050C  17A1     BSF data, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
050D  30FF     MOVLW 0xFF
050E  05A0     ANDWF __pcstackBANK0, F
050F  30FF     MOVLW 0xFF
0510  05A1     ANDWF data, F
0511  3000     MOVLW 0x0
0512  05A2     ANDWF i, F
103:           	f2_as_mant2 |= 0x8000UL;
0513  17A4     BSF counter, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
0514  30FF     MOVLW 0xFF
0515  05A3     ANDWF f2, F
0516  30FF     MOVLW 0xFF
0517  05A4     ANDWF counter, F
0518  3000     MOVLW 0x0
0519  05A5     ANDWF len, F
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
051A  087A     MOVF row, W
051B  027B     SUBWF addr, W
051C  1803     BTFSC STATUS, 0x0
051D  2D40     GOTO 0x540
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
051E  3001     MOVLW 0x1
051F  35A3     LSLF f2, F
0520  0DA4     RLF counter, F
0521  0DA5     RLF len, F
0522  0B89     DECFSZ WREG, F
0523  2D1F     GOTO 0x51F
111:           			exp2--;
0524  3001     MOVLW 0x1
0525  02FA     SUBWF row, F
112:           		} while(exp2 != exp1 && --sign & 7);
0526  087A     MOVF row, W
0527  067B     XORWF addr, W
0528  1903     BTFSC STATUS, 0x2
0529  2D3B     GOTO 0x53B
052A  3001     MOVLW 0x1
052B  02F9     SUBWF c, F
052C  0879     MOVF c, W
052D  3907     ANDLW 0x7
052E  1903     BTFSC STATUS, 0x2
052F  2D3B     GOTO 0x53B
0530  2D1E     GOTO 0x51E
113:           		while(exp1 != exp2) {
053B  087B     MOVF addr, W
053C  067A     XORWF row, W
053D  1903     BTFSC STATUS, 0x2
053E  2D65     GOTO 0x565
053F  2D31     GOTO 0x531
114:           			f1_as_mant1 >>= 1;
0531  3001     MOVLW 0x1
0532  36A2     LSRF i, F
0533  0CA1     RRF data, F
0534  0CA0     RRF __pcstackBANK0, F
0535  0B89     DECFSZ WREG, F
0536  2D32     GOTO 0x532
115:           			exp1++;
0537  3001     MOVLW 0x1
0538  00A6     MOVWF i
0539  0826     MOVF i, W
053A  07FB     ADDWF addr, F
116:           		}
117:           	} else if(exp1 > exp2) {
0540  087B     MOVF addr, W
0541  027A     SUBWF row, W
0542  1803     BTFSC STATUS, 0x0
0543  2D65     GOTO 0x565
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
0544  3001     MOVLW 0x1
0545  35A0     LSLF __pcstackBANK0, F
0546  0DA1     RLF data, F
0547  0DA2     RLF i, F
0548  0B89     DECFSZ WREG, F
0549  2D45     GOTO 0x545
122:           			exp1--;
054A  3001     MOVLW 0x1
054B  02FB     SUBWF addr, F
123:           		} while(exp2 != exp1 && --sign & 7);
054C  087A     MOVF row, W
054D  067B     XORWF addr, W
054E  1903     BTFSC STATUS, 0x2
054F  2D61     GOTO 0x561
0550  3001     MOVLW 0x1
0551  02F9     SUBWF c, F
0552  0879     MOVF c, W
0553  3907     ANDLW 0x7
0554  1903     BTFSC STATUS, 0x2
0555  2D61     GOTO 0x561
0556  2D44     GOTO 0x544
124:           		while(exp1 != exp2) {
0561  087B     MOVF addr, W
0562  067A     XORWF row, W
0563  1D03     BTFSS STATUS, 0x2
0564  2D57     GOTO 0x557
125:           			f2_as_mant2 >>= 1;
0557  3001     MOVLW 0x1
0558  36A5     LSRF len, F
0559  0CA4     RRF counter, F
055A  0CA3     RRF f2, F
055B  0B89     DECFSZ WREG, F
055C  2D58     GOTO 0x558
126:           			exp2++;
055D  3001     MOVLW 0x1
055E  00A6     MOVWF i
055F  0826     MOVF i, W
0560  07FA     ADDWF row, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
0565  1FF9     BTFSS c, 0x7
0566  2D77     GOTO 0x577
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
0567  30FF     MOVLW 0xFF
0568  06A0     XORWF __pcstackBANK0, F
0569  30FF     MOVLW 0xFF
056A  06A1     XORWF data, F
056B  30FF     MOVLW 0xFF
056C  06A2     XORWF i, F
132:           		f1_as_mant1++;
056D  3001     MOVLW 0x1
056E  07A0     ADDWF __pcstackBANK0, F
056F  3000     MOVLW 0x0
0570  1803     BTFSC STATUS, 0x0
0571  3001     MOVLW 0x1
0572  07A1     ADDWF data, F
0573  3000     MOVLW 0x0
0574  1803     BTFSC STATUS, 0x0
0575  3001     MOVLW 0x1
0576  07A2     ADDWF i, F
133:           	}
134:           	if(sign & 0x40) {
0577  1F79     BTFSS c, 0x6
0578  2D89     GOTO 0x589
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
0579  30FF     MOVLW 0xFF
057A  06A3     XORWF f2, F
057B  30FF     MOVLW 0xFF
057C  06A4     XORWF counter, F
057D  30FF     MOVLW 0xFF
057E  06A5     XORWF len, F
137:           		f2_as_mant2++;
057F  3001     MOVLW 0x1
0580  07A3     ADDWF f2, F
0581  3000     MOVLW 0x0
0582  1803     BTFSC STATUS, 0x0
0583  3001     MOVLW 0x1
0584  07A4     ADDWF counter, F
0585  3000     MOVLW 0x0
0586  1803     BTFSC STATUS, 0x0
0587  3001     MOVLW 0x1
0588  07A5     ADDWF len, F
138:           	}
139:           	sign = 0;
0589  01F9     CLRF c
140:           	f2_as_mant2 += f1_as_mant1;
058A  0820     MOVF __pcstackBANK0, W
058B  07A3     ADDWF f2, F
058C  0821     MOVF data, W
058D  3DA4     ADDWFC counter, F
058E  0822     MOVF i, W
058F  3DA5     ADDWFC len, F
141:           	if(f2_as_mant2 & 0x800000UL) {
0590  1FA5     BTFSS len, 0x7
0591  2DA4     GOTO 0x5A4
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
0592  30FF     MOVLW 0xFF
0593  06A3     XORWF f2, F
0594  30FF     MOVLW 0xFF
0595  06A4     XORWF counter, F
0596  30FF     MOVLW 0xFF
0597  06A5     XORWF len, F
143:           		f2_as_mant2++;
0598  3001     MOVLW 0x1
0599  07A3     ADDWF f2, F
059A  3000     MOVLW 0x0
059B  1803     BTFSC STATUS, 0x0
059C  3001     MOVLW 0x1
059D  07A4     ADDWF counter, F
059E  3000     MOVLW 0x0
059F  1803     BTFSC STATUS, 0x0
05A0  3001     MOVLW 0x1
05A1  07A5     ADDWF len, F
144:           		sign = 1;
05A2  01F9     CLRF c
05A3  0AF9     INCF c, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
05A4  0823     MOVF f2, W
05A5  00F1     MOVWF multiplier
05A6  0824     MOVF counter, W
05A7  00F2     MOVWF val
05A8  0825     MOVF len, W
05A9  00F3     MOVWF multiplicand
05AA  087B     MOVF addr, W
05AB  00A6     MOVWF i
05AC  0826     MOVF i, W
05AD  00F4     MOVWF ff2
05AE  0879     MOVF c, W
05AF  00A7     MOVWF row
05B0  0827     MOVF row, W
05B1  00F5     MOVWF product
05B2  318E     MOVLP 0xE
05B3  2600     CALL 0x600
05B4  0871     MOVF multiplier, W
05B5  0020     MOVLB 0x0
05B6  00A0     MOVWF __pcstackBANK0
05B7  0872     MOVF val, W
05B8  00A1     MOVWF data
05B9  0873     MOVF multiplicand, W
05BA  00A2     MOVWF i
05BB  0008     RETURN
147:           
148:           }
05BC  306F     MOVLW 0x6F
05BD  0020     MOVLB 0x0
05BE  00A0     MOVWF __pcstackBANK0
05BF  3000     MOVLW 0x0
05C0  00A1     MOVWF data
05C1  01A2     CLRF i
05C2  0AA2     INCF i, F
05C3  303B     MOVLW 0x3B
05C4  3188     MOVLP 0x8
05C5  20CF     CALL 0xCF
05C6  3185     MOVLP 0x5
149:           #endif
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/float.c  ----------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(unsigned short long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(unsigned short long * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (unsigned short long)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
0E00  0874     MOVF ff2, W
0E01  1903     BTFSC STATUS, 0x2
0E02  2E08     GOTO 0x608
0E03  0873     MOVF multiplicand, W
0E04  0472     IORWF val, W
0E05  0471     IORWF multiplier, W
0E06  1D03     BTFSS STATUS, 0x2
0E07  2E19     GOTO 0x619
65:            		return 0.0;
0E08  3000     MOVLW 0x0
0E09  00F1     MOVWF multiplier
0E0A  3000     MOVLW 0x0
0E0B  00F2     MOVWF val
0E0C  3000     MOVLW 0x0
0E0D  00F3     MOVWF multiplicand
0E0E  0008     RETURN
66:            	while(arg & 0xFE0000UL) {
0E19  30FE     MOVLW 0xFE
0E1A  0573     ANDWF multiplicand, W
0E1B  1903     BTFSC STATUS, 0x2
0E1C  2E32     GOTO 0x632
0E1D  2E0F     GOTO 0x60F
67:            		exp++;
0E0F  3001     MOVLW 0x1
0E10  00F6     MOVWF bf
0E11  0876     MOVF bf, W
0E12  07F4     ADDWF ff2, F
68:            		arg >>= 1;
0E13  3001     MOVLW 0x1
0E14  36F3     LSRF multiplicand, F
0E15  0CF2     RRF val, F
0E16  0CF1     RRF multiplier, F
0E17  0B89     DECFSZ WREG, F
0E18  2E14     GOTO 0x614
69:            	}
70:            	while(arg & 0xFF0000UL) {
0E32  30FF     MOVLW 0xFF
0E33  0573     ANDWF multiplicand, W
0E34  1903     BTFSC STATUS, 0x2
0E35  2E3F     GOTO 0x63F
0E36  2E1E     GOTO 0x61E
71:            		exp++;
0E1E  3001     MOVLW 0x1
0E1F  00F6     MOVWF bf
0E20  0876     MOVF bf, W
0E21  07F4     ADDWF ff2, F
72:            		(arg)++;
0E22  3001     MOVLW 0x1
0E23  07F1     ADDWF multiplier, F
0E24  3000     MOVLW 0x0
0E25  1803     BTFSC STATUS, 0x0
0E26  3001     MOVLW 0x1
0E27  07F2     ADDWF val, F
0E28  3000     MOVLW 0x0
0E29  1803     BTFSC STATUS, 0x0
0E2A  3001     MOVLW 0x1
0E2B  07F3     ADDWF multiplicand, F
73:            		arg >>= 1;
0E2C  3001     MOVLW 0x1
0E2D  36F3     LSRF multiplicand, F
0E2E  0CF2     RRF val, F
0E2F  0CF1     RRF multiplier, F
0E30  0B89     DECFSZ WREG, F
0E31  2E2D     GOTO 0x62D
74:            	}
75:            	while(!(arg & 0x8000UL)) {
0E3F  1FF2     BTFSS val, 0x7
0E40  2E37     GOTO 0x637
76:            		exp--;
0E37  3001     MOVLW 0x1
0E38  02F4     SUBWF ff2, F
77:            		arg <<= 1;
0E39  3001     MOVLW 0x1
0E3A  35F1     LSLF multiplier, F
0E3B  0DF2     RLF val, F
0E3C  0DF3     RLF multiplicand, F
0E3D  0B89     DECFSZ WREG, F
0E3E  2E3A     GOTO 0x63A
78:            	}
79:            	if(!(exp & 1))
0E41  1874     BTFSC ff2, 0x0
0E42  2E49     GOTO 0x649
80:            		arg &= ~0x8000L;
0E43  30FF     MOVLW 0xFF
0E44  05F1     ANDWF multiplier, F
0E45  307F     MOVLW 0x7F
0E46  05F2     ANDWF val, F
0E47  30FF     MOVLW 0xFF
0E48  05F3     ANDWF multiplicand, F
81:            	exp >>= 1;
0E49  1003     BCF STATUS, 0x0
0E4A  0CF4     RRF ff2, F
82:            	arg |= (unsigned short long)exp << 16;
0E4B  0874     MOVF ff2, W
0E4C  00F6     MOVWF bf
0E4D  01F7     CLRF rs
0E4E  01F8     CLRF col
0E4F  3010     MOVLW 0x10
0E50  35F6     LSLF bf, F
0E51  0DF7     RLF rs, F
0E52  0DF8     RLF col, F
0E53  0B89     DECFSZ WREG, F
0E54  2E50     GOTO 0x650
0E55  0876     MOVF bf, W
0E56  04F1     IORWF multiplier, F
0E57  0877     MOVF rs, W
0E58  04F2     IORWF val, F
0E59  0878     MOVF col, W
0E5A  04F3     IORWF multiplicand, F
83:            	if (sign)
0E5B  0875     MOVF product, W
0E5C  1903     BTFSC STATUS, 0x2
0E5D  0008     RETURN
84:            		arg |= 0x800000UL;
0E5E  17F3     BSF multiplicand, 0x7
85:               return *(float*)&arg;	
86:            }
0E5F  0008     RETURN
87:            
88:            #endif
---  C:/Programmi/Microchip/xc8/v1.21/sources/pic/awdiv.c  ----------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             __awdiv(signed int divisor, signed int dividend)
5:             {
6:             	signed int	quotient;
7:             	unsigned char	counter, sign;
8:             
9:             	sign = 0;
0D00  01F7     CLRF rs
10:            	if(divisor < 0) {
0D01  1FF2     BTFSS val, 0x7
0D02  2D0A     GOTO 0x50A
11:            		divisor = -divisor;
0D03  09F1     COMF multiplier, F
0D04  09F2     COMF val, F
0D05  0AF1     INCF multiplier, F
0D06  1903     BTFSC STATUS, 0x2
0D07  0AF2     INCF val, F
12:            		sign = 1;
0D08  01F7     CLRF rs
0D09  0AF7     INCF rs, F
13:            	}
14:            	if(dividend < 0) {
0D0A  1FF4     BTFSS ff2, 0x7
0D0B  2D15     GOTO 0x515
15:            		dividend = -dividend;
0D0C  09F3     COMF multiplicand, F
0D0D  09F4     COMF ff2, F
0D0E  0AF3     INCF multiplicand, F
0D0F  1903     BTFSC STATUS, 0x2
0D10  0AF4     INCF ff2, F
16:            		sign ^= 1;
0D11  3001     MOVLW 0x1
0D12  00F5     MOVWF product
0D13  0875     MOVF product, W
0D14  06F7     XORWF rs, F
17:            	}
18:            	quotient = 0;
0D15  01F8     CLRF col
0D16  01F9     CLRF c
19:            	if(divisor != 0) {
0D17  0872     MOVF val, W
0D18  0471     IORWF multiplier, W
0D19  1903     BTFSC STATUS, 0x2
0D1A  2D44     GOTO 0x544
20:            		counter = 1;
0D1B  01F6     CLRF bf
0D1C  0AF6     INCF bf, F
21:            		while((divisor & 0x8000U) == 0) {
0D1D  1BF2     BTFSC val, 0x7
0D1E  2D29     GOTO 0x529
0D28  2D1D     GOTO 0x51D
22:            			divisor <<= 1;
0D1F  3001     MOVLW 0x1
0D20  35F1     LSLF multiplier, F
0D21  0DF2     RLF val, F
0D22  0B89     DECFSZ WREG, F
0D23  2D20     GOTO 0x520
23:            			counter++;
0D24  3001     MOVLW 0x1
0D25  00F5     MOVWF product
0D26  0875     MOVF product, W
0D27  07F6     ADDWF bf, F
24:            		}
25:            		do {
26:            			quotient <<= 1;
0D29  3001     MOVLW 0x1
0D2A  35F8     LSLF col, F
0D2B  0DF9     RLF c, F
0D2C  0B89     DECFSZ WREG, F
0D2D  2D2A     GOTO 0x52A
27:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0D2E  0872     MOVF val, W
0D2F  0274     SUBWF ff2, W
0D30  1D03     BTFSS STATUS, 0x2
0D31  2D34     GOTO 0x534
0D32  0871     MOVF multiplier, W
0D33  0273     SUBWF multiplicand, W
0D34  1C03     BTFSS STATUS, 0x0
0D35  2D3B     GOTO 0x53B
28:            				dividend -= divisor;
0D36  0871     MOVF multiplier, W
0D37  02F3     SUBWF multiplicand, F
0D38  0872     MOVF val, W
0D39  3BF4     SUBWFB ff2, F
29:            				quotient |= 1;
0D3A  1478     BSF col, 0x0
30:            			}
31:            			*(unsigned int *)&divisor >>= 1;
0D3B  3001     MOVLW 0x1
0D3C  36F2     LSRF val, F
0D3D  0CF1     RRF multiplier, F
0D3E  0B89     DECFSZ WREG, F
0D3F  2D3C     GOTO 0x53C
32:            		} while(--counter != 0);
0D40  3001     MOVLW 0x1
0D41  02F6     SUBWF bf, F
0D42  1D03     BTFSS STATUS, 0x2
0D43  2D29     GOTO 0x529
33:            	}
34:            	if(sign)
0D44  0877     MOVF rs, W
0D45  1903     BTFSC STATUS, 0x2
0D46  2D4C     GOTO 0x54C
35:            		quotient = -quotient;
0D47  09F8     COMF col, F
0D48  09F9     COMF c, F
0D49  0AF8     INCF col, F
0D4A  1903     BTFSC STATUS, 0x2
0D4B  0AF9     INCF c, F
36:            	return quotient;
0D4C  0879     MOVF c, W
0D4D  01F2     CLRF val
0D4E  07F2     ADDWF val, F
0D4F  0878     MOVF col, W
0D50  01F1     CLRF multiplier
0D51  07F1     ADDWF multiplier, F
0D52  0008     RETURN
37:            }
0D53  00F7     MOVWF rs
---  C:/Programmi/Microchip/xc8/v1.21/sources/common/itoa.c  --------------------------------------------
1:             #include	<stdlib.h>
2:             	
3:             char *
4:             itoa(char * buf, int val, int base)
5:             {
098D  0020     MOVLB 0x0
098E  00AD     MOVWF f1
6:             	char *	cp = buf;
098F  082D     MOVF f1, W
0990  00FA     MOVWF row
0991  087A     MOVF row, W
0992  00AC     MOVWF cp
7:             
8:             	if(val < 0) {
0993  1FA9     BTFSS dividend, 0x7
0994  29A6     GOTO 0x1A6
9:             		*buf++ = '-';
0995  302D     MOVLW 0x2D
0996  00FA     MOVWF row
0997  082D     MOVF f1, W
0998  0086     MOVWF FSR1
0999  3001     MOVLW 0x1
099A  0087     MOVWF FSR1H
099B  087A     MOVF row, W
099C  0081     MOVWF INDF1
099D  3001     MOVLW 0x1
099E  00FA     MOVWF row
099F  087A     MOVF row, W
09A0  07AD     ADDWF f1, F
10:            		val = -val;
09A1  09A8     COMF src, F
09A2  09A9     COMF dividend, F
09A3  0AA8     INCF src, F
09A4  1903     BTFSC STATUS, 0x2
09A5  0AA9     INCF dividend, F
11:            	}
12:            	utoa(buf, val, base);
09A6  0829     MOVF dividend, W
09A7  01A1     CLRF data
09A8  07A1     ADDWF data, F
09A9  0828     MOVF src, W
09AA  01A0     CLRF __pcstackBANK0
09AB  07A0     ADDWF __pcstackBANK0, F
09AC  082B     MOVF f3_as_product, W
09AD  01A3     CLRF f2
09AE  07A3     ADDWF f2, F
09AF  082A     MOVF exp, W
09B0  01A2     CLRF i
09B1  07A2     ADDWF i, F
09B2  082D     MOVF f1, W
09B3  318E     MOVLP 0xE
09B4  2660     CALL 0x660
09B5  0008     RETURN
13:            	return cp;
14:            }
09B6  318A     MOVLP 0xA
15:            
16:            char *
17:            utoa(char * buf, unsigned val, int base)
18:            {
19:            	unsigned	v;
20:            	char		c;
21:            
22:            	v = val;
0E60  0020     MOVLB 0x0
0E61  00A7     MOVWF row
0E62  0821     MOVF data, W
0E63  01A5     CLRF len
0E64  07A5     ADDWF len, F
0E65  0820     MOVF __pcstackBANK0, W
0E66  01A4     CLRF counter
0E67  07A4     ADDWF counter, F
23:            	do {
24:            		v /= base;
0E68  0823     MOVF f2, W
0E69  01F2     CLRF val
0E6A  07F2     ADDWF val, F
0E6B  0822     MOVF i, W
0E6C  01F1     CLRF multiplier
0E6D  07F1     ADDWF multiplier, F
0E6E  0825     MOVF len, W
0E6F  01F4     CLRF ff2
0E70  07F4     ADDWF ff2, F
0E71  0824     MOVF counter, W
0E72  01F3     CLRF multiplicand
0E73  07F3     ADDWF multiplicand, F
0E74  318B     MOVLP 0xB
0E75  2322     CALL 0x322
0E76  318E     MOVLP 0xE
0E77  0872     MOVF val, W
0E78  0020     MOVLB 0x0
0E79  01A5     CLRF len
0E7A  07A5     ADDWF len, F
0E7B  0871     MOVF multiplier, W
0E7C  01A4     CLRF counter
0E7D  07A4     ADDWF counter, F
25:            		buf++;
0E7E  3001     MOVLW 0x1
0E7F  00F9     MOVWF c
0E80  0879     MOVF c, W
0E81  07A7     ADDWF row, F
26:            	} while(v != 0);
0E82  0825     MOVF len, W
0E83  0424     IORWF counter, W
0E84  1D03     BTFSS STATUS, 0x2
0E85  2E68     GOTO 0x668
27:            	*buf-- = 0;
0E86  0827     MOVF row, W
0E87  0086     MOVWF FSR1
0E88  3001     MOVLW 0x1
0E89  0087     MOVWF FSR1H
0E8A  0181     CLRF INDF1
0E8B  3001     MOVLW 0x1
0E8C  02A7     SUBWF row, F
28:            	do {
29:            		c = val % base;
0E8D  0823     MOVF f2, W
0E8E  01F2     CLRF val
0E8F  07F2     ADDWF val, F
0E90  0822     MOVF i, W
0E91  01F1     CLRF multiplier
0E92  07F1     ADDWF multiplier, F
0E93  0821     MOVF data, W
0E94  01F4     CLRF ff2
0E95  07F4     ADDWF ff2, F
0E96  0820     MOVF __pcstackBANK0, W
0E97  01F3     CLRF multiplicand
0E98  07F3     ADDWF multiplicand, F
0E99  318A     MOVLP 0xA
0E9A  2263     CALL 0x263
0E9B  318E     MOVLP 0xE
0E9C  0871     MOVF multiplier, W
0E9D  00F9     MOVWF c
0E9E  0879     MOVF c, W
0E9F  0020     MOVLB 0x0
0EA0  00A6     MOVWF i
30:            		val /= base;
0EA1  0823     MOVF f2, W
0EA2  01F2     CLRF val
0EA3  07F2     ADDWF val, F
0EA4  0822     MOVF i, W
0EA5  01F1     CLRF multiplier
0EA6  07F1     ADDWF multiplier, F
0EA7  0821     MOVF data, W
0EA8  01F4     CLRF ff2
0EA9  07F4     ADDWF ff2, F
0EAA  0820     MOVF __pcstackBANK0, W
0EAB  01F3     CLRF multiplicand
0EAC  07F3     ADDWF multiplicand, F
0EAD  318B     MOVLP 0xB
0EAE  2322     CALL 0x322
0EAF  318E     MOVLP 0xE
0EB0  0872     MOVF val, W
0EB1  0020     MOVLB 0x0
0EB2  01A1     CLRF data
0EB3  07A1     ADDWF data, F
0EB4  0871     MOVF multiplier, W
0EB5  01A0     CLRF __pcstackBANK0
0EB6  07A0     ADDWF __pcstackBANK0, F
31:            		if(c >= 10)
0EB7  300A     MOVLW 0xA
0EB8  0226     SUBWF i, W
0EB9  1C03     BTFSS STATUS, 0x0
0EBA  2EBF     GOTO 0x6BF
32:            			c += 'A'-'0'-10;
0EBB  3007     MOVLW 0x7
0EBC  00F9     MOVWF c
0EBD  0879     MOVF c, W
0EBE  07A6     ADDWF i, F
33:            		c += '0';
0EBF  3030     MOVLW 0x30
0EC0  00F9     MOVWF c
0EC1  0879     MOVF c, W
0EC2  07A6     ADDWF i, F
34:            		*buf-- = c;
0EC3  0826     MOVF i, W
0EC4  00F9     MOVWF c
0EC5  0827     MOVF row, W
0EC6  0086     MOVWF FSR1
0EC7  3001     MOVLW 0x1
0EC8  0087     MOVWF FSR1H
0EC9  0879     MOVF c, W
0ECA  0081     MOVWF INDF1
0ECB  3001     MOVLW 0x1
0ECC  02A7     SUBWF row, F
35:            	} while(val != 0);
0ECD  0821     MOVF data, W
0ECE  0420     IORWF __pcstackBANK0, W
0ECF  1D03     BTFSS STATUS, 0x2
0ED0  2E8D     GOTO 0x68D
36:            	return ++buf;
0ED1  3001     MOVLW 0x1
0ED2  00F9     MOVWF c
0ED3  0879     MOVF c, W
0ED4  07A7     ADDWF row, F
0ED5  0008     RETURN
37:            }
0ED6  0020     MOVLB 0x0
38:            
---  C:/Programmi/Microchip/xc8/v1.21/sources/common/isdigit.c  -----------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
15EB  00F2     MOVWF val
14:            	return c <= '9' && c >= '0';
15EC  01F1     CLRF multiplier
15ED  303A     MOVLW 0x3A
15EE  0272     SUBWF val, W
15EF  1803     BTFSC STATUS, 0x0
15F0  2DF7     GOTO 0x5F7
15F1  3030     MOVLW 0x30
15F2  0272     SUBWF val, W
15F3  1C03     BTFSS STATUS, 0x0
15F4  2DF7     GOTO 0x5F7
15F5  01F1     CLRF multiplier
15F6  0AF1     INCF multiplier, F
15F7  0C71     RRF multiplier, W
15F8  0008     RETURN
15:            }
15F9  0020     MOVLB 0x0
16:            
17:            #endif
---  C:/Programmi/Microchip/xc8/v1.21/sources/common/doprnt.c  ------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
0801  3401     RETLW 0x1
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
02EA  0020     MOVLB 0x0
02EB  00C1     MOVWF sp
02EC  302E     MOVLW 0x2E
02ED  00B6     MOVWF 0x36
02EE  0836     MOVF 0x36, W
02EF  00BC     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
02F0  082D     MOVF f1, W
02F1  0AAD     INCF f1, F
02F2  3188     MOVLP 0x8
02F3  000A     CALLW
02F4  3182     MOVLP 0x2
02F5  00B6     MOVWF 0x36
02F6  0836     MOVF 0x36, W
02F7  00C6     MOVWF c
02F8  08C6     MOVF c, F
02F9  1903     BTFSC STATUS, 0x2
02FA  2CC0     GOTO 0x4C0
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
02FB  0846     MOVF c, W
02FC  3A25     XORLW 0x25
02FD  1903     BTFSC STATUS, 0x2
02FE  2B0C     GOTO 0x30C
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
02FF  0846     MOVF c, W
0300  00B6     MOVWF 0x36
0301  0841     MOVF sp, W
0302  0086     MOVWF FSR1
0303  3001     MOVLW 0x1
0304  0087     MOVWF FSR1H
0305  0836     MOVF 0x36, W
0306  0081     MOVWF INDF1
0307  3001     MOVLW 0x1
0308  00B6     MOVWF 0x36
0309  0836     MOVF 0x36, W
030A  07C1     ADDWF sp, F
551:           			continue;
030B  2AF0     GOTO 0x2F0
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
030C  01C2     CLRF width
030D  01C3     CLRF 0x43
556:           #endif
557:           		flag = 0;
030E  01BB     CLRF flag
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
590:           				f++;
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
030F  082D     MOVF f1, W
0310  3188     MOVLP 0x8
0311  000A     CALLW
0312  3183     MOVLP 0x3
0313  3195     MOVLP 0x15
0314  25EB     CALL 0x5EB
0315  3182     MOVLP 0x2
0316  1C03     BTFSS STATUS, 0x0
0317  2B4B     GOTO 0x34B
607:           			width = 0;
0318  0020     MOVLB 0x0
0319  01C2     CLRF width
031A  01C3     CLRF 0x43
608:           			do {
609:           				width *= 10;
031B  300A     MOVLW 0xA
031C  00F1     MOVWF multiplier
031D  3000     MOVLW 0x0
031E  00F2     MOVWF val
031F  0020     MOVLB 0x0
0320  0843     MOVF 0x43, W
0321  01F4     CLRF ff2
0322  07F4     ADDWF ff2, F
0323  0842     MOVF width, W
0324  01F3     CLRF multiplicand
0325  07F3     ADDWF multiplicand, F
0326  3197     MOVLP 0x17
0327  27A7     CALL 0x7A7
0328  3182     MOVLP 0x2
0329  0872     MOVF val, W
032A  0020     MOVLB 0x0
032B  01C3     CLRF 0x43
032C  07C3     ADDWF 0x43, F
032D  0871     MOVF multiplier, W
032E  01C2     CLRF width
032F  07C2     ADDWF width, F
610:           			   	width += *f++ - '0';
0330  082D     MOVF f1, W
0331  3188     MOVLP 0x8
0332  000A     CALLW
0333  3183     MOVLP 0x3
0334  3ED0     ADDLW 0xD0
0335  00B6     MOVWF 0x36
0336  30FF     MOVLW 0xFF
0337  1803     BTFSC STATUS, 0x0
0338  3000     MOVLW 0x0
0339  00B7     MOVWF 0x37
033A  0836     MOVF 0x36, W
033B  07C2     ADDWF width, F
033C  0837     MOVF 0x37, W
033D  3DC3     ADDWFC 0x43, F
033E  3001     MOVLW 0x1
033F  00B6     MOVWF 0x36
0340  0836     MOVF 0x36, W
0341  07AD     ADDWF f1, F
611:           			} while(isdigit((unsigned)*f));
0342  082D     MOVF f1, W
0343  3188     MOVLP 0x8
0344  000A     CALLW
0345  3183     MOVLP 0x3
0346  3195     MOVLP 0x15
0347  25EB     CALL 0x5EB
0348  3182     MOVLP 0x2
0349  1803     BTFSC STATUS, 0x0
034A  2B1B     GOTO 0x31B
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
034B  0020     MOVLB 0x0
034C  082D     MOVF f1, W
034D  3188     MOVLP 0x8
034E  000A     CALLW
034F  3183     MOVLP 0x3
0350  3A2E     XORLW 0x2E
0351  1D03     BTFSS STATUS, 0x2
0352  2B88     GOTO 0x388
621:           			flag |= PRECISION;
622:           			f++;
0353  3001     MOVLW 0x1
0354  00B6     MOVWF 0x36
0355  0836     MOVF 0x36, W
0356  07AD     ADDWF f1, F
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
0357  01C4     CLRF prec
0358  01C5     CLRF 0x45
631:           				while(isdigit((unsigned)*f))
0359  082D     MOVF f1, W
035A  3188     MOVLP 0x8
035B  000A     CALLW
035C  3183     MOVLP 0x3
035D  3195     MOVLP 0x15
035E  25EB     CALL 0x5EB
035F  3182     MOVLP 0x2
0360  1C03     BTFSS STATUS, 0x0
0361  2B93     GOTO 0x393
0387  2B59     GOTO 0x359
632:           					prec = prec*10 + *f++ - '0';
0362  0020     MOVLB 0x0
0363  082D     MOVF f1, W
0364  3188     MOVLP 0x8
0365  000A     CALLW
0366  3183     MOVLP 0x3
0367  00B6     MOVWF 0x36
0368  01B7     CLRF 0x37
0369  0845     MOVF 0x45, W
036A  01F2     CLRF val
036B  07F2     ADDWF val, F
036C  0844     MOVF prec, W
036D  01F1     CLRF multiplier
036E  07F1     ADDWF multiplier, F
036F  300A     MOVLW 0xA
0370  00F3     MOVWF multiplicand
0371  3000     MOVLW 0x0
0372  00F4     MOVWF ff2
0373  3197     MOVLP 0x17
0374  27A7     CALL 0x7A7
0375  3182     MOVLP 0x2
0376  0020     MOVLB 0x0
0377  0836     MOVF 0x36, W
0378  0771     ADDWF multiplier, W
0379  00B8     MOVWF sign1
037A  0837     MOVF 0x37, W
037B  3D72     ADDWFC val, W
037C  00B9     MOVWF lval
037D  0838     MOVF sign1, W
037E  3ED0     ADDLW 0xD0
037F  00C4     MOVWF prec
0380  30FF     MOVLW 0xFF
0381  3D39     ADDWFC lval, W
0382  00C5     MOVWF 0x45
0383  3001     MOVLW 0x1
0384  00B6     MOVWF 0x36
0385  0836     MOVF 0x36, W
0386  07AD     ADDWF f1, F
633:           			}
634:           		} else {
635:           			prec = 0;
0388  0020     MOVLB 0x0
0389  01C4     CLRF prec
038A  01C5     CLRF 0x45
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
038B  2B93     GOTO 0x393
0393  0020     MOVLB 0x0
0394  082D     MOVF f1, W
0395  0AAD     INCF f1, F
0396  3188     MOVLP 0x8
0397  000A     CALLW
0398  3183     MOVLP 0x3
0399  00C6     MOVWF c
039A  3A00     XORLW 0x0
039B  1903     BTFSC STATUS, 0x2
039C  2CC0     GOTO 0x4C0
039D  3A6C     XORLW 0x6C
039E  1903     BTFSC STATUS, 0x2
039F  2B8C     GOTO 0x38C
03A0  3A19     XORLW 0x19
03A1  1903     BTFSC STATUS, 0x2
03A2  2B8E     GOTO 0x38E
03A3  2AF0     GOTO 0x2F0
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
038C  163B     BSF flag, 0x4
653:           			goto loop;
038D  2B93     GOTO 0x393
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
731:           #endif
732:           			break;
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
750:           				cp = "(null)";
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
755:           			while(cp[len])
756:           				len++;
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
767:           				width -= len;
768:           			else
769:           				width = 0;
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
774:           					pputc(' ');
775:           #endif	// WIDTH
776:           			while(len--)
777:           				pputc(*cp++);
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
815:           			len = 1;
816:           			goto dostring;
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
038E  30C0     MOVLW 0xC0
038F  00B6     MOVWF 0x36
0390  0836     MOVF 0x36, W
0391  04BB     IORWF flag, F
828:           			break;
829:           #endif
830:           
831:           		}
0392  2BA4     GOTO 0x3A4
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          						putsign();
1166:          #endif
1167:          #if defined(MANSIGN) && defined(SPCSIGN)
1168:          					else
1169:          #endif
1170:          #ifdef	SPCSIGN
1171:          					if(flag & SPCSIGN)
1172:          						pputc(' ');
1173:          #endif	// SPCSIGN
1174:          #ifdef	WIDTH
1175:          					while(width > 0) {
1176:          						pputc('0');
1177:          						width--;
1178:          					}
1179:          #endif	// WIDTH
1180:          				} else
1181:          #endif	// FILL
1182:          				{
1183:          #ifdef	LEFT
1184:          					if(!(flag & LEFT))
1185:          #endif
1186:          #ifdef	WIDTH
1187:          					while(width > 0) {
1188:          						pputc(' ');
1189:          						width--;
1190:          					}
1191:          #endif	// WIDTH
1192:          #ifdef	MANSIGN
1193:          				if(flag & MANSIGN)
1194:          #else
1195:          				if(flag & NEGSIGN)
1196:          #endif	// MANSIGN
1197:          					putsign();
1198:          #ifdef	SPCSIGN
1199:          				else if(flag & SPCSIGN)
1200:          					pputc(' ');
1201:          #endif	// SPCSIGN
1202:          			}
1203:          			while(c--) {
1204:          #if	DOUBLE
1205:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1206:          #else
1207:          				{
1208:          					unsigned vd = val/dpowers[c];
1209:          					vd %= 10;
1210:          					pputc('0' + vd);
1211:          				}
1212:          #endif	// DOUBLE
1213:          			}
1214:          			while(exp > 0) {
1215:          				pputc('0');
1216:          				exp--;
1217:          			}
1218:          			if(prec > (int)(NDDIG-2))
1219:          				c = NDDIG-2;
1220:          			else
1221:          				c = prec;
1222:          			prec -= c;
1223:          #ifdef	ALTERN
1224:          			if(c || flag & ALTERN)
1225:          #else
1226:          			if(c)
1227:          #endif
1228:          				pputc('.');
1229:          #if	DOUBLE
1230:          			ival = _dto64i(fval * scale(c));
1231:          			while(c)
1232:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1233:          #else	// DOUBLE
1234:          			val = (long)(fval * scale(c));
1235:          			while(c--) {
1236:          				unsigned vd = val/dpowers[c];
1237:          				vd %= 10;
1238:          				pputc('0' + vd);
1239:          				val %= dpowers[c];
1240:          			}
1241:          #endif	// DOUBLE
1242:          			while(prec) {
1243:          				pputc('0');
1244:          				prec--;
1245:          			}
1246:          #ifdef	LEFT
1247:          			if((flag & LEFT) && width > 0)
1248:          				do
1249:          					pputc(' ');
1250:          				while(--width);
1251:          #endif
1252:          			continue;
1253:          		}
1254:          #endif	/* __FLOAT */
1255:          
1256:          #if	defined(TEN)
1257:          #ifdef	BASEM
1258:          		if((flag & BASEM) == TEN)
1259:          #endif	//BASEM
1260:          		{
1261:          #ifdef	LONG
1262:          			if(flag & LONG)
1263:          				val = va_arg(ap, long);
1264:          			else
1265:          #endif	// LONG
1266:          				val = (value)va_arg(ap, int);
1267:          #ifdef	NEGSIGN
1268:          			if((value)val < 0) {
1269:          				flag |= NEGSIGN;
1270:          				val = -val;
1271:          			}
1272:          #endif
1273:          		}
1274:          #ifdef	BASEM
1275:          		else
1276:          #endif
1277:          #endif	// TEN
1278:          
1279:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1280:          		{
1281:          #ifdef	__LONG
1282:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1283:          			if(flag & POINTER)
1284:          				val = (unsigned long)va_arg(ap, far char *);
1285:          			else
1286:          #endif
1287:          #ifdef	LONG
1288:          				if(flag & LONG)
03A4  1E3B     BTFSS flag, 0x4
03A5  2BB3     GOTO 0x3B3
1289:          				val = va_arg(ap, unsigned long);
03A6  083C     MOVF ap, W
03A7  0086     MOVWF FSR1
03A8  0187     CLRF FSR1H
03A9  3F40     MOVIW [0]FSR1
03AA  00BD     MOVWF exp1
03AB  3F41     MOVIW [1]FSR1
03AC  00BE     MOVWF 0x3E
03AD  3F42     MOVIW [2]FSR1
03AE  00BF     MOVWF 0x3F
03AF  3F43     MOVIW [3]FSR1
03B0  00C0     MOVWF 0x40
03B1  3004     MOVLW 0x4
03B2  2BC1     GOTO 0x3C1
1290:          			else
1291:          #endif	// LONG
1292:          #endif	// __LONG
1293:          				val = va_arg(ap, unsigned);
03B3  083C     MOVF ap, W
03B4  0086     MOVWF FSR1
03B5  0187     CLRF FSR1H
03B6  3F40     MOVIW [0]FSR1
03B7  00B6     MOVWF 0x36
03B8  3F41     MOVIW [1]FSR1
03B9  00B7     MOVWF 0x37
03BA  0836     MOVF 0x36, W
03BB  00BD     MOVWF exp1
03BC  0837     MOVF 0x37, W
03BD  00BE     MOVWF 0x3E
03BE  01BF     CLRF 0x3F
03BF  01C0     CLRF 0x40
03C0  3002     MOVLW 0x2
03C1  00B6     MOVWF 0x36
03C2  0836     MOVF 0x36, W
03C3  07BC     ADDWF ap, F
1294:          		}
1295:          #endif	// EIGHT or SIXTEEN or UNSIGN
1296:          #ifdef	PRECISION
1297:          		if(prec == 0 && val == 0)
03C4  0845     MOVF 0x45, W
03C5  0444     IORWF prec, W
03C6  1D03     BTFSS STATUS, 0x2
03C7  2BD2     GOTO 0x3D2
03C8  0840     MOVF 0x40, W
03C9  043F     IORWF 0x3F, W
03CA  043E     IORWF 0x3E, W
03CB  043D     IORWF exp1, W
03CC  1D03     BTFSS STATUS, 0x2
03CD  2BD2     GOTO 0x3D2
1298:          			prec++;
03CE  3001     MOVLW 0x1
03CF  07C4     ADDWF prec, F
03D0  3000     MOVLW 0x0
03D1  3DC5     ADDWFC 0x45, F
1299:          #endif
1300:          #ifdef	MULTRAD
1301:          		switch((unsigned char)(flag & BASEM)) {
1302:          #endif
1303:          #if	defined(TEN) || defined(UNSIGN)
1304:          #ifdef	MULTRAD
1305:          #ifdef	TEN
1306:          		case TEN:
1307:          #endif
1308:          #ifdef	UNSIGN
1309:          		case UNSIGN:
1310:          #endif
1311:          #endif	// MULTRAD
1312:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
03D2  01C6     CLRF c
03D3  0AC6     INCF c, F
03D4  0846     MOVF c, W
03D5  3A0A     XORLW 0xA
03D6  1903     BTFSC STATUS, 0x2
03D7  2C07     GOTO 0x407
03FF  3001     MOVLW 0x1
0400  00B6     MOVWF 0x36
0401  0836     MOVF 0x36, W
0402  07C6     ADDWF c, F
0403  0846     MOVF c, W
0404  3A0A     XORLW 0xA
0405  1D03     BTFSS STATUS, 0x2
0406  2BD8     GOTO 0x3D8
1313:          				if(val < dpowers[c])
03D8  3001     MOVLW 0x1
03D9  0084     MOVWF FSR0
03DA  3088     MOVLW 0x88
03DB  0085     MOVWF FSR0H
03DC  0846     MOVF c, W
03DD  00B6     MOVWF 0x36
03DE  3001     MOVLW 0x1
03DF  35B6     LSLF 0x36, F
03E0  3EFF     ADDLW 0xFF
03E1  1D03     BTFSS STATUS, 0x2
03E2  2BDF     GOTO 0x3DF
03E3  3536     LSLF 0x36, W
03E4  0784     ADDWF FSR0, F
03E5  1803     BTFSC STATUS, 0x0
03E6  0A85     INCF FSR0H, F
03E7  3F00     MOVIW [0]FSR0
03E8  00B7     MOVWF 0x37
03E9  3F01     MOVIW [1]FSR0
03EA  00B8     MOVWF sign1
03EB  3F02     MOVIW [2]FSR0
03EC  00B9     MOVWF lval
03ED  3F03     MOVIW [3]FSR0
03EE  00BA     MOVWF 0x3A
03EF  083A     MOVF 0x3A, W
03F0  0240     SUBWF 0x40, W
03F1  1D03     BTFSS STATUS, 0x2
03F2  2BFD     GOTO 0x3FD
03F3  0839     MOVF lval, W
03F4  023F     SUBWF 0x3F, W
03F5  1D03     BTFSS STATUS, 0x2
03F6  2BFD     GOTO 0x3FD
03F7  0838     MOVF sign1, W
03F8  023E     SUBWF 0x3E, W
03F9  1D03     BTFSS STATUS, 0x2
03FA  2BFD     GOTO 0x3FD
03FB  0837     MOVF 0x37, W
03FC  023D     SUBWF exp1, W
03FD  1C03     BTFSS STATUS, 0x0
03FE  2C07     GOTO 0x407
1314:          					break;
1315:          #ifdef	MULTRAD
1316:          			break;
1317:          #endif
1318:          #endif	// TEN || UNSIGN
1319:          #ifdef	SIXTEEN
1320:          #ifdef	MULTRAD
1321:          		case SIXTEEN:
1322:          #endif	// MULTRAD
1323:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1324:          				if(val < hexpowers[c])
1325:          					break;
1326:          #ifdef	MULTRAD
1327:          			break;
1328:          #endif
1329:          #endif
1330:          
1331:          #ifdef	EIGHT
1332:          #ifdef	MULTRAD
1333:          		case EIGHT:
1334:          #endif	// MULTRAD
1335:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1336:          				if(val < octpowers[c])
1337:          					break;
1338:          #ifdef	MULTRAD
1339:          			break;
1340:          #endif
1341:          #endif
1342:          #ifdef	MULTRAD
1343:          		}
1344:          #endif
1345:          #ifdef	PRECISION
1346:          		if(c < prec)
0407  0846     MOVF c, W
0408  00B6     MOVWF 0x36
0409  01B7     CLRF 0x37
040A  1BB6     BTFSC 0x36, 0x7
040B  03B7     DECF 0x37, F
040C  0837     MOVF 0x37, W
040D  3A80     XORLW 0x80
040E  00B8     MOVWF sign1
040F  0845     MOVF 0x45, W
0410  3A80     XORLW 0x80
0411  0238     SUBWF sign1, W
0412  1D03     BTFSS STATUS, 0x2
0413  2C16     GOTO 0x416
0414  0844     MOVF prec, W
0415  0236     SUBWF 0x36, W
0416  1803     BTFSC STATUS, 0x0
0417  2C1E     GOTO 0x41E
1347:          			c = prec;
0418  0020     MOVLB 0x0
0419  0844     MOVF prec, W
041A  00B6     MOVWF 0x36
041B  0836     MOVF 0x36, W
041C  00C6     MOVWF c
041D  2C36     GOTO 0x436
1348:          		else if(prec < c)
041E  0020     MOVLB 0x0
041F  0846     MOVF c, W
0420  00B6     MOVWF 0x36
0421  01B7     CLRF 0x37
0422  1BB6     BTFSC 0x36, 0x7
0423  03B7     DECF 0x37, F
0424  0845     MOVF 0x45, W
0425  3A80     XORLW 0x80
0426  00B8     MOVWF sign1
0427  0837     MOVF 0x37, W
0428  3A80     XORLW 0x80
0429  0238     SUBWF sign1, W
042A  1D03     BTFSS STATUS, 0x2
042B  2C2E     GOTO 0x42E
042C  0836     MOVF 0x36, W
042D  0244     SUBWF prec, W
042E  1803     BTFSC STATUS, 0x0
042F  2C36     GOTO 0x436
1349:          			prec = c;
0430  0020     MOVLB 0x0
0431  0846     MOVF c, W
0432  00C4     MOVWF prec
0433  01C5     CLRF 0x45
0434  1BC4     BTFSC prec, 0x7
0435  03C5     DECF 0x45, F
1350:          #endif
1351:          #if	defined(WIDTH) && defined(NEGSIGN)
1352:          		if(width && flag & NEGSIGN)
1353:          			width--;
1354:          #ifdef	PRECISION
1355:          		if(flag & PRECISION) {
1356:          			if(width > prec)
1357:          				width -= prec;
1358:          			else
1359:          				width = 0;
1360:          		}
1361:          #endif
1362:          #ifdef	ALTERN
1363:          #ifdef	EIGHT
1364:          		if((flag & (
1365:          #ifdef	FILL
1366:          						FILL|
1367:          #endif
1368:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1369:          			if(width)
1370:          				width--;
1371:          		} else
1372:          #endif	// EIGHT
1373:          #if	defined(SIXTEEN)
1374:          #ifdef	BASEM
1375:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1376:          #else
1377:          		if(flag & ALTERN) {
1378:          #endif
1379:          			if(width > 2)
1380:          				width -= 2;
1381:          			else
1382:          				width = 0;
1383:          		}
1384:          #endif	// SIXTEEN
1385:          #endif	// ALTERN
1386:          #endif	// WIDTH
1387:          #ifdef	WIDTH
1388:          		if(width > c)
0436  0020     MOVLB 0x0
0437  0846     MOVF c, W
0438  00B6     MOVWF 0x36
0439  01B7     CLRF 0x37
043A  1BB6     BTFSC 0x36, 0x7
043B  03B7     DECF 0x37, F
043C  0837     MOVF 0x37, W
043D  3A80     XORLW 0x80
043E  00B8     MOVWF sign1
043F  0843     MOVF 0x43, W
0440  3A80     XORLW 0x80
0441  0238     SUBWF sign1, W
0442  1D03     BTFSS STATUS, 0x2
0443  2C46     GOTO 0x446
0444  0842     MOVF width, W
0445  0236     SUBWF 0x36, W
0446  1803     BTFSC STATUS, 0x0
0447  2C53     GOTO 0x453
1389:          			width -= c;
0448  0020     MOVLB 0x0
0449  0846     MOVF c, W
044A  00B6     MOVWF 0x36
044B  01B7     CLRF 0x37
044C  1BB6     BTFSC 0x36, 0x7
044D  03B7     DECF 0x37, F
044E  0836     MOVF 0x36, W
044F  02C2     SUBWF width, F
0450  0837     MOVF 0x37, W
0451  3BC3     SUBWFB 0x43, F
0452  2C56     GOTO 0x456
1390:          		else
1391:          			width = 0;
0453  0020     MOVLB 0x0
0454  01C2     CLRF width
0455  01C3     CLRF 0x43
1392:          #endif
1393:          #ifdef	FILL
1394:          		if(flag & FILL) {
1395:          #ifdef	MANSIGN
1396:          			if(flag & MANSIGN)
1397:          				putsign();
1398:          #elif defined(NEGSIGN)
1399:          			if(flag & NEGSIGN)
1400:          				pputc('-');
1401:          #endif
1402:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1403:          			else
1404:          #endif	// MANSIGN
1405:          #ifdef	SPCSIGN
1406:          			if(flag & SPCSIGN)
1407:          				pputc(' ');
1408:          #endif
1409:          #if defined(ALTERN) && defined(SIXTEEN)
1410:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1411:          				pputc('0');
1412:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1413:          				pputc(flag & UPCASE ? 'X' : 'x');
1414:          #elif defined(HEXUPCASE)
1415:          				pputc('X');
1416:          #else
1417:          				pputc('x');
1418:          #endif	// HEXUPCASE
1419:          			}
1420:          #endif	// ALTERN
1421:          #ifdef	WIDTH
1422:          			if(width)
1423:          				do
1424:          					pputc('0');
1425:          				while(--width);
1426:          #endif	// WIDTH
1427:          		} else
1428:          #endif	//FILL
1429:          		{
1430:          #ifdef	WIDTH
1431:          			if(width
1432:          #ifdef	LEFT
1433:          					&& !(flag & LEFT)
1434:          #endif
1435:          					)
0456  0843     MOVF 0x43, W
0457  0442     IORWF width, W
0458  1903     BTFSC STATUS, 0x2
0459  2CB3     GOTO 0x4B3
1436:          				do
1437:          					pputc(' ');
045A  3020     MOVLW 0x20
045B  00B6     MOVWF 0x36
045C  0841     MOVF sp, W
045D  0086     MOVWF FSR1
045E  3001     MOVLW 0x1
045F  0087     MOVWF FSR1H
0460  0836     MOVF 0x36, W
0461  0081     MOVWF INDF1
0462  3001     MOVLW 0x1
0463  00B6     MOVWF 0x36
0464  0836     MOVF 0x36, W
0465  07C1     ADDWF sp, F
1438:          				while(--width);
0466  30FF     MOVLW 0xFF
0467  07C2     ADDWF width, F
0468  30FF     MOVLW 0xFF
0469  3DC3     ADDWFC 0x43, F
046A  2C56     GOTO 0x456
1439:          #endif	// WIDTH
1440:          #ifdef	MANSIGN
1441:          			if(flag & MANSIGN)
1442:          				putsign();
1443:          #else
1444:          #ifdef	NEGSIGN
1445:          			if(flag & NEGSIGN)
1446:          				pputc('-');
1447:          #endif
1448:          #endif	// MANSIGN
1449:          #ifdef	SPCSIGN
1450:          			else if(flag & SPCSIGN)
1451:          				pputc(' ');
1452:          #endif
1453:          #ifdef	ALTERN
1454:          #ifdef	EIGHT
1455:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1456:          				pputc('0');
1457:          			else
1458:          #endif	// EIGHT
1459:          #ifdef	SIXTEEN
1460:          #ifdef	BASEM
1461:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1462:          #else
1463:          			if(flag & ALTERN) {
1464:          #endif
1465:          				pputc('0');
1466:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1467:          				pputc(flag & UPCASE ? 'X' : 'x');
1468:          #elif defined(HEXUPCASE)
1469:          				pputc('X');
1470:          #else
1471:          				pputc('x');
1472:          #endif
1473:          			}
1474:          #endif	// SIXTEEN
1475:          #endif	// ALTERN
1476:          		}
1477:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1478:          #ifndef	PRECISION
1479:          		prec = c;
1480:          #endif
1481:          		while(prec--) {
04B3  30FF     MOVLW 0xFF
04B4  07C4     ADDWF prec, F
04B5  30FF     MOVLW 0xFF
04B6  3DC5     ADDWFC 0x45, F
04B7  30FF     MOVLW 0xFF
04B8  0645     XORWF 0x45, W
04B9  1D03     BTFSS STATUS, 0x2
04BA  2CBD     GOTO 0x4BD
04BB  30FF     MOVLW 0xFF
04BC  0644     XORWF prec, W
04BD  1903     BTFSC STATUS, 0x2
04BE  2AF0     GOTO 0x2F0
04BF  2C6B     GOTO 0x46B
1482:          #ifdef	MULTRAD
1483:          			switch((unsigned char)(flag & BASEM))
1484:          #endif
1485:          			{
1486:          
1487:          #if	defined(TEN) || defined(UNSIGN)
1488:          #ifdef	MULTRAD
1489:          #ifdef	TEN
1490:          		case TEN:
1491:          #endif
1492:          #ifdef	UNSIGN
1493:          		case UNSIGN:
1494:          #endif
1495:          #endif	// MULTRAD
1496:          				c = (val / dpowers[prec]) % 10 + '0';
046B  3000     MOVLW 0x0
046C  00A8     MOVWF src
046D  3000     MOVLW 0x0
046E  00A7     MOVWF row
046F  3000     MOVLW 0x0
0470  00A6     MOVWF i
0471  300A     MOVLW 0xA
0472  00A5     MOVWF len
0473  3001     MOVLW 0x1
0474  0084     MOVWF FSR0
0475  3088     MOVLW 0x88
0476  0085     MOVWF FSR0H
0477  0844     MOVF prec, W
0478  00B6     MOVWF 0x36
0479  3001     MOVLW 0x1
047A  35B6     LSLF 0x36, F
047B  3EFF     ADDLW 0xFF
047C  1D03     BTFSS STATUS, 0x2
047D  2C7A     GOTO 0x47A
047E  3536     LSLF 0x36, W
047F  0784     ADDWF FSR0, F
0480  1803     BTFSC STATUS, 0x0
0481  0A85     INCF FSR0H, F
0482  3F00     MOVIW [0]FSR0
0483  00F1     MOVWF multiplier
0484  3F01     MOVIW [1]FSR0
0485  00F2     MOVWF val
0486  3F02     MOVIW [2]FSR0
0487  00F3     MOVWF multiplicand
0488  3F03     MOVIW [3]FSR0
0489  00F4     MOVWF ff2
048A  0840     MOVF 0x40, W
048B  00F8     MOVWF col
048C  083F     MOVF 0x3F, W
048D  00F7     MOVWF rs
048E  083E     MOVF 0x3E, W
048F  00F6     MOVWF bf
0490  083D     MOVF exp1, W
0491  00F5     MOVWF product
0492  318C     MOVLP 0xC
0493  24AD     CALL 0x4AD
0494  3182     MOVLP 0x2
0495  0874     MOVF ff2, W
0496  0020     MOVLB 0x0
0497  00AC     MOVWF cp
0498  0873     MOVF multiplicand, W
0499  00AB     MOVWF f3_as_product
049A  0872     MOVF val, W
049B  00AA     MOVWF exp
049C  0871     MOVF multiplier, W
049D  00A9     MOVWF dividend
049E  318B     MOVLP 0xB
049F  23D3     CALL 0x3D3
04A0  3182     MOVLP 0x2
04A1  0020     MOVLB 0x0
04A2  0825     MOVF len, W
04A3  3E30     ADDLW 0x30
04A4  00B7     MOVWF 0x37
04A5  0837     MOVF 0x37, W
04A6  00C6     MOVWF c
1497:          #ifdef	MULTRAD
1498:          				break;
1499:          #endif
1500:          #endif	// TEN || UNSIGN
1501:          
1502:          #ifdef	SIXTEEN
1503:          #ifdef	MULTRAD
1504:          			case SIXTEEN:
1505:          #endif
1506:          			{
1507:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1508:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1509:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1510:          #elif	defined(HEXUPCASE)
1511:          				c = "0123456789ABCDEF"[idx];
1512:          #else
1513:          				c = "0123456789abcdef"[idx];
1514:          #endif	//HEXCASE
1515:          			}
1516:          #ifdef	MULTRAD
1517:          				break;
1518:          #endif
1519:          #endif
1520:          
1521:          #ifdef	EIGHT
1522:          #ifdef	MULTRAD
1523:          			case EIGHT:
1524:          #endif	// MULTRAD
1525:          				c = ((val / octpowers[prec]) & 07) + '0';
1526:          #ifdef	MULTRAD
1527:          				break;
1528:          #endif	// MULTRAD
1529:          #endif	// EIGHT
1530:          			}
1531:          			pputc(c);
04A7  0846     MOVF c, W
04A8  00B6     MOVWF 0x36
04A9  0841     MOVF sp, W
04AA  0086     MOVWF FSR1
04AB  3001     MOVLW 0x1
04AC  0087     MOVWF FSR1H
04AD  0836     MOVF 0x36, W
04AE  0081     MOVWF INDF1
04AF  3001     MOVLW 0x1
04B0  00B6     MOVWF 0x36
04B1  0836     MOVF 0x36, W
04B2  07C1     ADDWF sp, F
1532:          		}
1533:          #endif	// 16 or 10 or 8
1534:          #ifdef	LEFT
1535:          		if((flag & LEFT) && width > 0)
1536:          			do
1537:          				pputc(' ');
1538:          			while(--width);
1539:          #endif	// LEFT
1540:          	}
1541:          #ifdef	ANYFORMAT
1542:          alldone:
1543:          #endif	// ANYFORMAT
1544:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1545:          	*sp = 0;
04C0  0841     MOVF sp, W
04C1  0086     MOVWF FSR1
04C2  3001     MOVLW 0x1
04C3  0087     MOVWF FSR1H
04C4  0181     CLRF INDF1
04C5  0008     RETURN
1546:          #endif
1547:          	return ccnt;
1548:          }
04C6  0020     MOVLB 0x0
1549:          
